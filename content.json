{"pages":[{"title":"About","date":"2020-01-16T16:32:44.547Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-01-16T16:32:44.547Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-01-16T16:32:44.547Z","path":"tags/index.html","text":""}],"posts":[{"title":"Refences Log","date":"2020-02-06T16:43:57.585Z","path":"wiki/Raspberry_Pi_PCR/References/","text":"参考文献ヒータ選定：https://jp.misumi-ec.com/vona2/detail/110300386860/https://www.kyocera.co.jp/prdct/fc/product/pdf/heaters.pdfhttps://www.kyocera.co.jp/prdct/fc/product/pdf/heaters.pdfhttps://jp.c.misumi-ec.com/book/MSM1_12/pdf/1683.pdf フォトカプラ特性トリガーLED電流https://toshiba-semicon-storage.com/content/dam/toshiba-ss/jp/docs/design-support/elearning/elearning_discrete05_r51.pdf RTD白金抵抗体：http://www.ni.com/tutorial/7115/ja/http://www.ti.com/lit/an/sbaa275/sbaa275.pdf photodiode:https://ja.wikipedia.org/wiki/フォトダイオードhttps://ja.wikipedia.org/wiki/光起電力効果 マイコン種類http://rtmrw.parallel.jp/led-work/raspberrypi/raspberrypi-1/doc-1.pdf データーシートヒータ：https://jp.misumi-ec.com/vona2/detail/110300386860/?bid=bid_basic_shape_templatehttps://jp.c.misumi-ec.com/book/MSM1_12/pdf/1707.pdf フォトカプラhttp://akizukidenshi.com/download/ds/toshiba/tlp241a.pdf PT1000:https://www.te.com/commerce/DocumentDelivery/DDEController?Action=showdoc&amp;DocId=Data+Sheet%7FPTF-FAMILY%7FA2%7Fpdf%7FEnglish%7FENG_DS_PTF-FAMILY_A2.pdf%7FNB-PTCO-168 UVLEDhttps://www.tech-led.com/wp-content/uploads/2015/03/SPEC-XFVL-1H321.pdf フォトダイオードhttps://www.kyosemi.co.jp/sensor/si_uv_sensor/kpdu400f_2/ motor driverhttps://www.mouser.jp/datasheet/2/408/TA7291FG_datasheet_en_20070613-1132057.pdf","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"绘图","date":"2020-01-23T13:02:13.670Z","path":"wiki/Note Collections/绘图/绘图/","text":"绘图卡扣","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"绘图","slug":"Note-Collections/绘图","permalink":"http://yoursite.com/categories/Note-Collections/%E7%BB%98%E5%9B%BE/"}]},{"title":"Note Collections：Dva,爱你哦~","date":"2020-01-16T20:21:19.325Z","path":"wiki/Note Collections/Codes/index/","text":"本站地址：– https://lovedva.github.io 托管于github上，国内部分地区可能访问缓慢或者无法访问,请访问coding话说这个Live2D的小人点它居然会说话♂ 更新日志:2020.1.23 搬家完成，添加基础评论2019.2.6 Dva，爱你哦~2018.7.13 不知道怎么弄评论，蓝瘦，香菇","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"Codes","slug":"Note-Collections/Codes","permalink":"http://yoursite.com/categories/Note-Collections/Codes/"}]},{"title":"RasPi Leaf 印刷用","date":"2020-01-06T07:50:10.712Z","path":"wiki/Raspberry_Pi_PCR/RasPi Leaf 印刷用/","text":"[TOC] RasPi Leaf 印刷用使い方 ダウンロード リンクhttps://github.com/splitbrain/rpibplusleaf/blob/master/rpiblusleaf.pdf References 参考文献：http://www.doctormonk.com/2013/02/raspberry-pi-and-breadboard-raspberry.html","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"プロキシー設定","date":"2020-01-06T07:50:10.712Z","path":"wiki/Raspberry_Pi_PCR/プロキシー設定/","text":"プロキシー設定1.次のコマンドを使って「/etc/apt/apt.conf.d/」ディレクトリに入るcd /etc/apt/apt.conf.d/ 2.「10proxy」という名前のファイルを作るnanoプログラムを利用して、次のコマンドでファイルを作る。 sudo nano /etc/apt/apt.conf.d/10proxy 3.プロキシーの設定を入力するプロキシーの設定テキストを”10proxy”ファイルに入れる。 Acquire::http::Proxy &quot;http://202.18.172.35:80&quot;; 4.ファイルを保存する「Crl」キーと「O」キーを同時に押し、ファイル名を確認して「Enter」キーで保存する。「Crl」キーと「X」キーを同時に押してnanoを終了、ターミナルに戻る。 5.RaspberryPiを再起動する再起動でプロキシーの設定を有効させる。References 参考文献：http://mrchrisjbailey.co.uk/2013/03/19/connecting-raspberry-pi-through-school-proxy/","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"リモート操作","date":"2020-01-06T07:50:10.712Z","path":"wiki/Raspberry_Pi_PCR/リモート操作/","text":"[TOC] リモート操作リモート操作の初期設定… LANケーブルでつなぐ場合1.RaspberryPiのLANポートとパソコンのLANポートをLANケーブルでつなぐ。2.Raspiの電源を入れ、起動完了までまつ。3.パソコンのターミナルを起動する。プログラムとファイル検索で「cmd」を検索して、「cmd」を起動する。 4.以下のコマンドを使って、RasPiのIPアドレスを探す。1arp -a 5.SSHクライアントで、RasPiのIPを入れるIPを入れたら「Connect」をクリックする。 6.RasPiのユーザネームとパスワードでログインする12Username:piPassword:raspberry 7.VNCサーバーを起動する最新のバージョンのRasbianでは，VNCServerがすでにインストールされたので，次のコマンドでVNCサーバーを起動,ユーザー名はpiで,パスワード(raspberry)を入力してOK。 1vncserver :1 8.パソコンのVNCクライアントでRasPiのデスクトップに入るVNCクライアントを起動する。 [RasPiのIPアドレス]:1を入れて、「Connect」をクリックする。 設定されたVNCサーバのパスワードを使ってRasPiのデスクトップに入る。 完了。RasPiの電源を切ると、1から8までを繰り返し、リモート操作が再開される。 WIFIでつなぐ場合… IPアドレスを固定するIPアドレスを固定する1.RasPiのSDカードをパソコンに差し込んで，ルートディレクトリを開いて，「cmdline.txt 」というファイルを編集する。 2．一番前のところでIPアドレスの設定を追加する。 パソコンがルータとして使われている場合，RasPiのIPアドレスを固定するには，パソコンのネットワークセグメントと同じIPアドレスにする必要がある。例えば, 次のコマンドでIP検索を行う。 1arp -a ここで、「169.254.54.6」はパソコンのIPアドレスである。 そして、「160.254.190.109」はRasPiのIPアドレスである。 パソコンと同じネットワークセグメントと言うのは、IPアドレスは「160.254.xxx.xxx」になること。この場合では、メモ帳ファイルの一番前に入れるテキストは 1ip&#x3D;160.254.190.100 であれば、RasPiのIPアドレスは「160.254.190.100」に固定する。他のルータを使う場合は、このようにルータのネットワークセグメントと同じにするように設定してください。 ファイル転送1.WinSCPをインストールする説明：https://winscp.net/eng/docs/lang:jpダウンロード：https://winscp.net/eng/download.php 2.SSHでログインする 3.ファイルを編集･新規する「デスクトップ」をダブルクリックして,デスクトップに入る. ファイルを選択し,右クリックして,ファイルを編集する. ファイルあるいはフォルダー（ディレクトリ）を新規する. ファイルを転送する.","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"Install OS","date":"2020-01-06T07:50:10.711Z","path":"wiki/Raspberry_Pi_PCR/Install OS/","text":"Install OS2017.10.26 #1 公式サイトでOSファイルをダウンロードするデスクトップ付けのZIPフィルをダウンロードする：https://www.raspberrypi.org/downloads/raspbian/ 7-Zip（圧縮・解凍ソフト）Download：https://sevenzip.osdn.jp/ #2 Win32 Disk ImagerをインストールするWin32 Disk Imager[^1] このプログラムは、RAWディスクイメージをリムーバブルデバイスに書き込むか、もしくはリムーバブルデバイスをRAWイメージディスクにバックアップすることに設計されています。 Download：https://sourceforge.net/projects/win32diskimager/ #3 OSファイルをSDカードに書き込む1.ZIPファイルを解凍する解凍ソフトがない場合は「7-Zip」をインストールしてください。ZIPファイルを解凍して、OSのディスクイメージファイル[^2]（IMGファイル）を得る。 2.OSファイルをSDカードに書き込むWin32 Disk Imagerを使ってイメージファイルを書き込む。 イメージファイルとSDカードのドライブを選択して、「Write」をクリックすると書き込みが開始される。書き込みが終わったら、OSのインストールが完了する。 [^1]:Win32 Disk Imagerの説明： https://ja.osdn.net/projects/sfnet_win32diskimager/[^2]:イメージファイルとは https://www.gigafree.net/faq/word/imgfile.html","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"初期設定","date":"2020-01-06T07:50:10.711Z","path":"wiki/Raspberry_Pi_PCR/初期設定/","text":"初期設定RaspberryPiにUSBケーブルを使って電源と接続すると、起動が開始される。電源が入っている場合は、赤いランプが点灯する。 # 言語設定1.ラズベリーパイのアイコン（メニュー）をクリックして＞Preferences＞Raspberry Pi Configurationを選択すると、設定ツールを起動する。 2.Localisationタブに入って、Set Localeをクリックする。ここで、日本語に設定する。 3.タイムゾーンをTokyoに設定する。Set Timezoneをクリックする。 4.日本語キーボードを使ってる場合は、キーボード配列を日本語に変更する。Set Keyboardをクリックする。CountryをJanpan、VariantをJapaneseを設定する。 5.無線LANの利用場所をJP Japanに設定する。Set Wifi Countryをクリックして、JP Japanを選択する。 6.全ての設定が終わったら、OKをクリックすして、RaspberryPiを再起動する。ここで、OKをクリックする。 再起動が完了するまで待つ。 ＃インターネットに接続するLANの場合LANケーブルをRaspberryPiに入れる。 無線LANの場合1.右上のネットワークアイコンをクリックする。 2.パスワードを入力する。 最新状態に更新するプロキシーが要る場合は先に#プロクシーを設定してください 1.ターミナルアイコンをクリックして、ターミナルを起動する。 2.「sudo」コマンドで管理者権限になり、「apt」コマンドで「update」サブコマンドを実行して、サーバー上のパッケージを取得する。 ======= # 日本語フォントをインストールする1sudo apt install fonts-ipafont fonts-ipaexfont fonts-takao 確認を求められたら,「Y」を入力してインストールする. インストールが終わったら、再起動する。","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"専門用語の説明","date":"2020-01-06T07:50:10.710Z","path":"wiki/Raspberry_Pi_PCR/専門用語の説明/","text":"[TOC] 専門用語の説明Win32 Disk Imager https://ja.osdn.net/projects/sfnet_win32diskimager/ このプログラムは、RAWディスクイメージをリムーバブルデバイスに書き込むか、もしくはリムーバブルデバイスをRAWイメージディスクにバックアップすることに設計されています。これはAndroidやUbuntu on ArmといったArm用の組込み開発にとって非常に有用です。誰もがプロジェクトを分機し、改変することもできます。パッチはいつも歓迎です。 イメージファイル（IMG拡張子）https://www.gigafree.net/faq/word/imgfile.htmlイメージファイル（イメージ）とは、簡単に言うとディスクの中身を、一つにまとめたファイル（ ＝ ディスクそのもの）のことです（「イメージファイル」「イメージ」「ディスクイメージ」などは、全て同じ意味）CD / DVD / BD / ハードディスク 等の中身を、 “ そっくりそのまま ” 取り出したような感じのファイルで、中身は元のディスクと “ 全く ” 同じです。「そっくりそのまま」の形式なので、劣化なくバックアップしたい完全な形でバックアップしたい品質を損なわずにバックアップしたいという時に最適なフォーマットなのです。（圧縮されている訳ではないので、ファイルサイズは元のディスクと同じになります）そのイメージファイルの標準規格 が「ISO」であり、「ISO」イメージファイルは “ 様々なOS 上で読み込むことができる ” という特徴を持っています1。 ディレクトリhttps://ja.wikipedia.org/wiki/%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AAディレクトリ (英: directory) は、コンピュータのファイルシステムにおいて、ファイルをグループ化するための特殊なファイルで、整理・管理などの目的で活用される。ディレクトリの中にも、通常のファイルだけでなく入れ子的にディレクトリを作って、任意の階層を持たせて管理できることがほとんどである。初心者向けの解説書などではファイルの入れ物（容器）などと表現されることもある（ただし、実際には、入れ物（容器）であるのはメディアそのものであって、ディレクトリは「ファイルへの見出しの入れ物」である）。","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"","date":"2019-09-19T00:06:58.642Z","path":"wiki/Note Collections/JavaEE 学习笔记/04-面向对象-继承&多态/01-笔记/","text":"笔记静态修饰符Static修饰的对象属于类的加载而加载（优先于对象加载），初始值为null，被所有对象共享。在一开始随着类的加载而加载到方法区","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"04-面向对象-继承&多态","slug":"Note-Collections/JavaEE-学习笔记/04-面向对象-继承-多态","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81/"}]},{"title":"","date":"2019-09-19T00:06:58.641Z","path":"wiki/Note Collections/JavaEE 学习笔记/03-常用API/03-IO流/","text":"IO流第10天 IO今日内容介绍 IO流概述及FileWriter类使用 FileReader类使用 缓冲流介绍和使用 IO流相关案例第1章 IO流概述及FileWriter类使用1.1 IO流概述及分类 IO流用来处理设备之间的数据传输 Java对数据的操作是通过流的方式 Java用于操作流的类都在IO包中 流按流向分为两种：输入流，输出流 1.2 FileWriter类使用A:打开帮助文档B:点击显示，找到索引，看到输入框C:你要学习什么内容，你就在框框里面输入什么内容 举例：RandomD:看包java.lang包下的类在使用的时候是不需要导包的E:看类的描述 Random类是用于生成随机数的类F:看构造方法 Random():无参构造方法 Random r = new Random();G:看成员方法 public int nextInt(int n):产生的是一个[0,n)范围内的随机数 调用方法： 看返回值类型：人家返回什么类型，你就用什么类型接收 看方法名：名字不要写错了 看形式参数：人家要几个参数，你就给几个，人家要什么数据类型的，你就给什么数据类型的 int number = r.nextInt(100);1.2.1 FileWriter向文件中写数据A:FileWriter向文件中写数据操作步骤: a:使用FileWriter流关联文件 b:利用FileWriter的写方法写数据 c:利用FileWriter的刷新方法将数据从内存刷到硬盘上 d:利用FileWriter的关流方法将释放占用的系统底层资源 B:FileWriter方法:构造方法FileWriter(String fileName) 传入一个文件的路径成员方法void write(String str) 向文件中写strvoid flush() 将内存中的数据刷新到文件中void close() 关流释放系统底层资源 1.2.1.1 案例代码一:package com.itheima_01;import java.io.FileWriter;import java.io.IOException; /* 需求：往文件中写数据 写数据–输出流–FileWriter FileWriter: FileWriter(String fileName):传递一个文件名称 输出流写数据的步骤： A:创建输出流对象 B:调用输出流对象的写数据的方法 C:释放资源 /public class FileWriterDemo { public static void main(String[] args) throws IOException { //创建输出流对象 FileWriter fw = new FileWriter(&quot;d:\\\\a.txt&quot;); /* * 创建输出流对象做了哪些事情: * A:调用系统资源创建了一个文件 * B:创建输出流对象 * C:把输出流对象指向文件 */ //调用输出流对象的写数据的方法 //写一个字符串数据 fw.write(&quot;IO流你好&quot;); //数据没有直接写到文件，其实是写到了内存缓冲区 fw.flush(); //释放资源 //通知系统释放和该文件相关的资源 即使没有flush，close也会检查缓冲区有没有字符并且输出缓冲区内容。 fw.close(); //while(true) {} }} 1.2.2 FileWriter注意事项1.2.2.1 案例代码二:package com.itheima_01; import java.io.FileWriter;import java.io.IOException; /* 输出流写数据的步骤： A:创建输出流对象 B:调用输出流对象的写数据方法，并刷新缓冲区 C:释放资源 相对路径：相对当前项目而言的，在项目的根目录下(a.txt) 绝对路径：以盘符开始的路径(d:\\a.txt) close()和flush()方法的区别： flush():刷新缓冲区。流对象还可以继续使用。 close():先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 /public class FileWriterDemo2 { public static void main(String[] args) throws IOException { //创建输出流对象 //FileWriter fw = new FileWriter(&quot;d:\\\\a.txt&quot;); FileWriter fw = new FileWriter(&quot;a.txt&quot;); //调用输出流对象的写数据方法，并刷新缓冲区 fw.write(&quot;helloworld&quot;); fw.flush(); fw.write(&quot;java&quot;); fw.flush(); //释放资源 fw.close(); //Stream closed //fw.write(&quot;javaee&quot;); //fw.flush(); }} 1.2.3 FileWriter其它写方法void write(String str):写一个字符串数据void write(String str,int index,int len):写一个字符串中的一部分数据void write(int ch):写一个字符数据,这里写int类型的好处是既可以写char类型的数据，也可以写char对应的int类型的值。’a’,97void write(char[] chs):写一个字符数组数据void write(char[] chs,int index,int len):写一个字符数组的一部分数据1.2.3.1 案例代码三:package com.itheima_01;import java.io.FileWriter;import java.io.IOException; /* void write(String str):写一个字符串数据 void write(String str,int index,int len):写一个字符串中的一部分数据 void write(int ch):写一个字符数据,这里写int类型的好处是既可以写char类型的数据，也可以写char对应的int类型的值。’a’,97 void write(char[] chs):写一个字符数组数据 void write(char[] chs,int index,int len):写一个字符数组的一部分数据 /public class FileWriterDemo3 { public static void main(String[] args) throws IOException { //创建输出流对象 FileWriter fw = new FileWriter(&quot;b.txt&quot;); //void write(String str):写一个字符串数据 //fw.write(&quot;abcde&quot;); //void write(String str,int index,int len):写一个字符串中的一部分数据 //fw.write(&quot;abcde&quot;,0,5); //fw.write(&quot;abcde&quot;,1,3); //void write(int ch):写一个字符数据,这里写int类型的好处是既可以写char类型的数据，也可以写char对应的int类型的值。&apos;a&apos;,97 //fw.write(&apos;a&apos;); //fw.write(97); //void write(char[] chs):写一个字符数组数据 char[] chs = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}; //fw.write(chs); //void write(char[] chs,int index,int len):写一个字符数组的一部分数据 //fw.write(chs,0,5); fw.write(chs,2,3); //释放资源 fw.close(); }} 1.2.4 FileWriter写入换行以及向文本末尾追加1.2.4.1 案例代码四:package com.itheima_01; import java.io.FileWriter;import java.io.IOException; /* 如何实现数据的换行? \\n可以实现换行，但是windows系统自带的记事本打开并没有换行，这是为什么呢?因为windows识别的换行不是\\n，而是\\r\\n windows:\\r\\n linux:\\n mac:\\r 如何实现数据的追加写入? FileWriter(String fileName, boolean append) /public class FileWriterDemo4 { public static void main(String[] args) throws IOException { //创建输出流对象 //FileWriter fw = new FileWriter(&quot;c.txt&quot;); FileWriter fw = new FileWriter(&quot;c.txt&quot;,true); //表示追加写入，默认是false for(int x=0; x&lt;10; x++) { fw.write(&quot;hello&quot;+x); fw.write(&quot;\\r\\n&quot;); } //释放资源 fw.close(); }} FileReader类使用 FileReader类使用第2章 FileReader类使用2.1 FileReader读数据一次读取一个字符2.1.1 案例代码五:package com.itheima_02;import java.io.FileReader;import java.io.IOException; /* 需求：从文件中读数据并显示到控制台 读数据–输入流–FileReader FileReader: FileReader(String fileName):传递文件名称 输入流读文件的步骤： A:创建输入流对象 B:调用输入流对象的读数据方法 C:释放资源 java.io.FileNotFoundException: fr.txt (系统找不到指定的文件。) /public class FileReaderDemo { public static void main(String[] args) throws IOException { //创建输入流对象// FileReader fr = new FileReader(“fr.txt”); FileReader fr = new FileReader(&quot;FileWriterDemo.java&quot;); //调用输入流对象的读数据方法 //int read():一次读取一个字符 /* //第一次读数据 int ch = fr.read(); System.out.println(ch); System.out.println((char)ch); //第二次读数据 ch = fr.read(); System.out.println(ch); System.out.println((char)ch); //第三次读数据 ch = fr.read(); System.out.println(ch); System.out.println((char)ch); //这是时候，我们发现代码的重复度很高，想用循环改进，但是不知道循环的结束条件是什么 ch = fr.read(); System.out.println(ch); ch = fr.read(); System.out.println(ch); //通过测试，我们知道，如果读取数据的返回值是-1的时候，就说明没有数据了，这也是我们循环的结束条件 */ int ch; //1:fr.read() //2:ch=fr.read() //3:ch != -1 while((ch=fr.read())!=-1) { //System.out.println(ch); //System.out.println((char)ch); System.out.print((char)ch); } //释放资源 fr.close(); }}2.2 利用FileReader和FileWriter完成文件复制2.2.1 读一次写一次 2.2.1.1 案例代码六:package com.itheima_03;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException; /* 需求： 把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中 文件复制也是有规律可循的，也就是说有套路。 数据源： FileWriterDemo.java – 读数据 – FileReader 目的地： Copy.java – 写数据 – FileWriter /public class CopyFileDemo { public static void main(String[] args) throws IOException { //创建输入流对象 FileReader fr = new FileReader(&quot;FileWriterDemo.java&quot;); //创建输出流对象 FileWriter fw = new FileWriter(&quot;Copy.java&quot;); //读写数据 int ch; while((ch=fr.read())!=-1) { fw.write(ch); } //释放资源 fw.close(); fr.close(); }} 2.2.2 利用字符数组拷贝文件 2.2.2.1 案例代码七:package com.itheima_03; import java.io.FileReader;import java.io.FileWriter;import java.io.IOException; /* 需求： 把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中 数据源： FileWriterDemo.java – 读数据 – FileReader 目的地： Copy.java – 写数据 – FileWriter /public class CopyFileDemo2 { public static void main(String[] args) throws IOException { //创建输入流对象 FileReader fr = new FileReader(&quot;FileWriterDemo.java&quot;); //创建输出流对象 FileWriter fw = new FileWriter(&quot;Copy.java&quot;); //读写数据 char[] chs = new char[1024]; int len; while((len=fr.read(chs))!=-1) { fw.write(chs, 0, len); } //释放资源 fw.close(); fr.close(); }} 2.2.3 拷贝文件的两种方式图解 第3章 缓冲流介绍和使用3.1 缓冲流的基本使用3.1.1 案例代码八:package com.itheima_04; import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException; /* BufferedWriter:将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 BufferedReader:从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 /public class BufferedStreamDemo { public static void main(String[] args) throws IOException { //创建输出缓冲流对象 /* BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); bw.write(&quot;hello&quot;); //bw.flush(); bw.close(); */ //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;FileWriterDemo.java&quot;)); /* //一次读写一个字符 int ch; while((ch=br.read())!=-1){ System.out.print((char)ch); } */ //一次读写一个字符数组 char[] chs = new char[1024]; int len; while((len=br.read(chs))!=-1) { System.out.print(new String(chs,0,len)); } //释放资源 br.close(); }} 3.2 缓冲流复制文本文件的两种方式 利用缓冲流把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中 第一种方式:使用缓冲流不使用字符数组 第二种方式:使用缓冲流使用字符数组3.2.1 案例代码九:package com.itheima_04; import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException; /* 需求： 把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中 数据源： FileWriterDemo.java – 读数据 – FileReader – 高效的读数据 – BufferedReader 目的地： Copy.java – 写数据 – FileWriter – 高效的写数据 – BufferedWriter /public class CopyFileDemo { public static void main(String[] args) throws IOException { //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;FileWriterDemo.java&quot;)); //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;Copy.java&quot;)); //读写数据 /* //一次读写一个字符 int ch; while((ch=br.read())!=-1) { bw.write(ch); } */ //一次读写一个字符数组 char[] chs = new char[1024]; int len; while((len=br.read(chs))!=-1) { bw.write(chs,0,len); } //释放资源 bw.close(); br.close(); }} 3.3 缓冲流的特有方法使用 BufferedWriter void newLine():写一个换行符，这个换行符由系统决定,不同的操作系统newLine()方法使用的换行符不同windows:\\r\\nlinux:\\nmac:\\r BufferedReader String readLine():一次读取一行数据，但是不读取换行符3.3.1 案例代码十:package com.itheima_05;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException; /* 缓冲流的特殊功能： BufferedWriter void newLine():写一个换行符，这个换行符由系统决定 BufferedReader String readLine():一次读取一行数据，但是不读取换行符 /public class BufferedStreamDemo { public static void main(String[] args) throws IOException { /* BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw2.txt&quot;)); for(int x=0; x&lt;10; x++) { bw.write(&quot;hello&quot;+x); //bw.write(&quot;\\r\\n&quot;); bw.newLine(); bw.flush(); } bw.close(); */ BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;)); /* String line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); */ String line; //1:br.readLine() //2:line=br.readLine() //3:line != null while((line=br.readLine())!=null) { System.out.println(line); } br.close(); }} 3.4 缓冲流的特有方法复制文件3.4.1 案例代码十一:package com.itheima_05;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/* 需求： 把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中 数据源： FileWriterDemo.java – 读数据 – FileReader – 高效的读数据 – BufferedReader 目的地： Copy.java – 写数据 – FileWriter – 高效的写数据 – BufferedWriter /public class CopyFileDemo { public static void main(String[] args) throws IOException { //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;FileWriterDemo.java&quot;)); //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;Copy.java&quot;)); //读写数据 String line; while((line=br.readLine())!=null) { bw.write(line); bw.newLine(); bw.flush(); } //释放资源 bw.close(); br.close(); }} 第4章 IO流相关案例4.1 复制文本文件的5种方式A:利用基本流一次读写一个字符B:利用基本流一次读写一个字符数组C:利用缓冲流一次读写一个字符D:利用缓冲流一次读写一个字符数组E:利用缓冲流的特有方法一次读写一个字符串4.1.1 案例代码十二:package com.itheima_06; import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException; /* 复制文本文件(5种方式) 数据源： FileWriterDemo.java 目的地： Copy.java /public class CopyFileTest { public static void main(String[] args) throws IOException { /* method1(&quot;FileWriterDemo.java&quot;,&quot;Copy.java&quot;); method2(&quot;FileWriterDemo.java&quot;,&quot;Copy.java&quot;); method3(&quot;FileWriterDemo.java&quot;,&quot;Copy.java&quot;); method4(&quot;FileWriterDemo.java&quot;,&quot;Copy.java&quot;); method5(&quot;FileWriterDemo.java&quot;,&quot;Copy.java&quot;); */ String srcFileName = &quot;FileWriterDemo.java&quot;; String destFileName = &quot;Copy.java&quot;; // method1(srcFileName,destFileName);// method2(srcFileName,destFileName); method3(srcFileName,destFileName);// method4(srcFileName,destFileName);// method5(srcFileName,destFileName); } //缓冲流一次读写一个字符串 public static void method5(String srcFileName,String destFileName) throws IOException { //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(srcFileName)); //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(destFileName)); //一次读写一个字符串 String line; while((line=br.readLine())!=null){ bw.write(line); bw.newLine(); bw.flush(); } //释放资源 bw.close(); br.close(); } //缓冲流一次读写一个字符数组 public static void method4(String srcFileName,String destFileName) throws IOException { //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(srcFileName)); //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(destFileName)); //一次读写一个字符数组 char[] chs = new char[1024]; int len; while((len=br.read(chs))!=-1) { bw.write(chs,0,len); } //释放资源 bw.close(); br.close(); } //缓冲流一次读写一个字符 public static void method3(String srcFileName,String destFileName) throws IOException { //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(srcFileName)); //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(destFileName)); //一次读写一个字符 int ch; while((ch=br.read())!=-1) { bw.write(ch); } //释放资源 bw.close(); br.close(); } //基本流一次读写一个字符数组 public static void method2(String srcFileName,String destFileName) throws IOException { //创建输入流对象 FileReader fr = new FileReader(srcFileName); //创建输出流对象 FileWriter fw = new FileWriter(destFileName); //一次读写一个字符数组 char[] chs = new char[1024]; int len; while((len=fr.read(chs))!=-1) { fw.write(chs,0,len); } //释放资源 fw.close(); fr.close(); } //基本流一次读写一个字符 public static void method1(String srcFileName,String destFileName) throws IOException { //创建输入流对象 FileReader fr = new FileReader(srcFileName); //创建输出流对象 FileWriter fw = new FileWriter(destFileName); //一次读写一个字符 int ch; while((ch=fr.read())!=-1) { fw.write(ch); } //释放资源 fw.close(); fr.close(); }} 4.2 把集合中的数据写到文本文件把ArrayList集合中的字符串数据存储到文本文件项目根目下的array.txt中每一个字符串元素作为文件中的一行数据4.2.1 案例代码十三:package com.itheima_06; import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList; /* 把ArrayList集合中的字符串数据存储到文本文件 每一个字符串元素作为文件中的一行数据 分析： A:创建集合对象 B:往集合中添加字符串元素 C:创建输出缓冲流对象 D:遍历集合，得到每一个字符串元素，然后把该字符串元素作为数据写到文本文件 E:释放资源 /public class ArrayListToFileTest { public static void main(String[] args) throws IOException { //创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //往集合中添加字符串元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;array.txt&quot;)); //遍历集合，得到每一个字符串元素，然后把该字符串元素作为数据写到文本文件 for(int x=0; x&lt;array.size(); x++) { String s = array.get(x); bw.write(s); bw.newLine(); bw.flush(); } //释放资源 bw.close(); }} 4.3 把文本文件中的数据读取到集合 从项目根目录下的array.txt文本文件中读取数据到ArrayList集合中，并遍历集合,每一行数据作为一个字符串元素4.3.1 案例代码十四:package com.itheima_06;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList; /* 从文本文件中读取数据到ArrayList集合中，并遍历集合 每一行数据作为一个字符串元素 分析： A:创建输入缓冲流对象 B:创建集合对象 C:读取数据，每次读取一行数据，把该行数据作为一个元素存储到集合中 D:释放资源 E:遍历集合 /public class FileToArrayListTest { public static void main(String[] args) throws IOException { //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;array.txt&quot;)); //创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //读取数据，每次读取一行数据，把该行数据作为一个元素存储到集合中 String line; while((line=br.readLine())!=null) { array.add(line); } //释放资源 br.close(); //遍历集合 for(int x=0; x&lt;array.size(); x++) { String s = array.get(x); System.out.println(s); } }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"03-常用API","slug":"Note-Collections/JavaEE-学习笔记/03-常用API","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03-%E5%B8%B8%E7%94%A8API/"}]},{"title":"","date":"2019-09-19T00:06:58.641Z","path":"wiki/Note Collections/JavaEE 学习笔记/03-常用API/02-集合ArryList/","text":"集合ArryList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099第09天 java集合今日内容介绍 对象数组 集合类之ArrayList 学生管理系统案例第1章 对象数组1.1 对象数组概述 A:基本类型的数组:存储的元素为基本类型int[] arr&#x3D;&#123;1,2,3,4&#125;B:对象数组:存储的元素为引用类型 Student[] stus&#x3D;new Student[3]; Student代表一个自定义类Stus数组中stus[0],stus[1],stus[2]的元素数据类型为Student, 都可以指向一个Student对象1.2 对象数组案例: 创建一个学生数组，存储三个学生对象并遍历1.2.1 案例代码一: package com.itheima;&#x2F;* * 自动生成构造方法： * 代码区域右键 -- Source -- Generate Constructors from Superclass... 无参构造方法 * 代码区域右键 -- Source -- Generate Constructor using Fields... 带参构造方法 * 自动生成getXxx()&#x2F;setXxx(): * 代码区域右键 -- Source -- Generate Getters and Setters... *&#x2F;public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125;package com.itheima;&#x2F;* * 创建一个学生数组，存储三个学生对象并遍历 * * 分析： * A:定义学生类 * B:创建学生数组 * C:创建学生对象 * D:把学生对象作为元素赋值给学生数组 * E:遍历学生数组 *&#x2F;public class StudentDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建学生数组 Student[] students &#x3D; new Student[3]; &#x2F;&#x2F;创建学生对象 Student s1 &#x3D; new Student(&quot;曹操&quot;,40); Student s2 &#x3D; new Student(&quot;刘备&quot;,35); Student s3 &#x3D; new Student(&quot;孙权&quot;,30); &#x2F;&#x2F;把学生对象作为元素赋值给学生数组 students[0] &#x3D; s1; students[1] &#x3D; s2; students[2] &#x3D; s3; &#x2F;&#x2F;遍历学生数组 for(int x&#x3D;0; x&lt;students.length; x++) &#123; Student s &#x3D; students[x]; &#x2F;&#x2F;System.out.println(s); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125;&#125;1.3 对象数组的内存图![](assets&#x2F;3&#x2F;20190208-e2398c7f.png) 第2章 集合类之ArrayList2.1 集合概述A:我们学习的是面向对象编程语言，而面向对象编程语言对事物的描述都是通过对象来体现的。 为了方便对多个对象进行操作，我们就必须对这多个对象进行存储，而要想对多个对象进行存储， 就不能是一个基本的变量，而应该是一个容器类型的变量。B:到目前为止，我们学习过了哪些容器类型的数据呢？StringBuilder,数组。 StringBuilder的结果只能是一个字符串类型，不一定满足我们的需求。 所以，我们目前只能选择数组了，也就是我们前面学习过的对象数组。 但是，数组的长度是固定的， 如果有时候元素的个数不确定的,我们无法定义出数组的长度,这个时候，java就提供了集合类供我们使用。2.2 ArrayList集合2.2.1 ArrayList添加新元素2.2.1.1 案例代码二:package com.itheima_01;import java.util.ArrayList;&#x2F;* * 为什么会出现集合类： * 我们学习的是面向对象编程语言，而面向对象编程语言对事物的描述都是通过对象来体现的。 * 为了方便对多个对象进行操作，我们就必须对这多个对象进行存储，而要想对多个对象进行存储， * 就不能是一个基本的变量，而应该是一个容器类型的变量。 * 到目前为止，我们学习过了哪些容器类型的数据呢？StringBuilder,数组。 * StringBuilder的结果只能是一个字符串类型，不一定满足我们的需求。 * 所以，我们目前只能选择数组了，也就是我们前面学习过的对象数组。 * 但是，数组的长度是固定的，适应不了变化的需求，那么，我们该如何选择呢? * 这个时候，java就提供了集合类供我们使用。 * * 集合类的特点： * 长度可变。 * * ArrayList&lt;E&gt;: * 大小可变数组的实现 * * &lt;E&gt;:是一种特殊的数据类型，泛型。 * 怎么用呢? * 在出现E的地方我们使用引用数据类型替换即可 * 举例：ArrayList&lt;String&gt;,ArrayList&lt;Student&gt; * * 构造方法： * ArrayList() * * 添加元素： * public boolean add(E e):添加元素 * public void add(int index,E element):在指定的索引处添加一个元素 *&#x2F;public class ArrayListDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象 ArrayList&lt;String&gt; array &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;add(E e):添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); &#x2F;&#x2F;add(int index,E element):在指定的索引处添加一个元素 &#x2F;&#x2F;array.add(1, &quot;android&quot;); System.out.println(&quot;array:&quot;+array); &#125;&#125;2.2.2 ArrayList删改查方法A:获取元素 public E get(int index):返回指定索引处的元素B:集合长度 public int size():返回集合中的元素的个数C:删除元素 public boolean remove(Object o):删除指定的元素，返回删除是否成功 public E remove(int index):删除指定索引处的元素，返回被删除的元素D:修改元素public E set(int index,E element):修改指定索引处的元素，返回被修改的元素2.2.2.1 案例代码三:package com.itheima_01;import java.util.ArrayList;&#x2F;* * 获取元素 * public E get(int index):返回指定索引处的元素 * 集合长度 * public int size():返回集合中的元素的个数 * 删除元素 * public boolean remove(Object o):删除指定的元素，返回删除是否成功 * public E remove(int index):删除指定索引处的元素，返回被删除的元素 * 修改元素 * public E set(int index,E element):修改指定索引处的元素，返回被修改的元素 *&#x2F;public class ArrayListDemo2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象 ArrayList&lt;String&gt; array &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); &#x2F;&#x2F;public E get(int index):返回指定索引处的元素 &#x2F;&#x2F;System.out.println(&quot;get:&quot;+array.get(0)); &#x2F;&#x2F;System.out.println(&quot;get:&quot;+array.get(1)); &#x2F;&#x2F;System.out.println(&quot;get:&quot;+array.get(2)); &#x2F;&#x2F;public int size():返回集合中的元素的个数 &#x2F;&#x2F;System.out.println(&quot;size:&quot;+array.size()); &#x2F;&#x2F;public boolean remove(Object o):删除指定的元素，返回删除是否成功 &#x2F;&#x2F;System.out.println(&quot;remove:&quot;+array.remove(&quot;world&quot;));&#x2F;&#x2F;true &#x2F;&#x2F;System.out.println(&quot;remove:&quot;+array.remove(&quot;world&quot;));&#x2F;&#x2F;false &#x2F;&#x2F;public E remove(int index):删除指定索引处的元素，返回被删除的元素 &#x2F;&#x2F;System.out.println(&quot;remove:&quot;+array.remove(0)); &#x2F;&#x2F;public E set(int index,E element):修改指定索引处的元素，返回被修改的元素 System.out.println(&quot;set:&quot;+array.set(1, &quot;android&quot;)); &#x2F;&#x2F;输出 System.out.println(&quot;array:&quot;+array); &#125;&#125;2.2.3 ArrayList遍历集合的遍历思想和数组的遍历思想相同循环遍历容器,依次取出里面的元素即可2.2.3.1 案例代码四:package com.itheima_01;import java.util.ArrayList;&#x2F;* * ArrayList集合的遍历 * 通过size()和get()配合实现的 *&#x2F;public class ArrayListDemo3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象 ArrayList&lt;String&gt; array &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); &#x2F;&#x2F;获取元素 &#x2F;&#x2F;原始做法 System.out.println(array.get(0)); System.out.println(array.get(1)); System.out.println(array.get(2)); System.out.println(&quot;----------&quot;); for(int x&#x3D;0; x&lt;3; x++) &#123; System.out.println(array.get(x)); &#125; System.out.println(&quot;----------&quot;); &#x2F;&#x2F;如何知道集合中元素的个数呢?size() for(int x&#x3D;0; x&lt;array.size(); x++) &#123; System.out.println(array.get(x)); &#125; System.out.println(&quot;----------&quot;); &#x2F;&#x2F;最标准的用法 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; String s &#x3D; array.get(x); System.out.println(s); &#125; &#125;&#125;2.3 ArrayList集合案例2.3.1 ArrayList练习之存储字符串并遍历 向集合中添加任意四个字符串,遍历集合,依次打印取出的字符串2.3.1.1 案例代码五:package com.itheima_02;import java.util.ArrayList;&#x2F;* * 存储字符串并遍历 * * 分析： * A:创建集合对象 * B:添加字符串元素 * C:遍历集合 *&#x2F;public class ArrayListTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象 ArrayList&lt;String&gt; array &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;添加字符串元素 array.add(&quot;向问天&quot;); array.add(&quot;刘正风&quot;); array.add(&quot;左冷禅&quot;); array.add(&quot;风清扬&quot;); &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; String s &#x3D; array.get(x); System.out.println(s); &#125; &#125;&#125;2.3.2 ArrayList练习之获取满足要求的元素 给定一个字符串数组：&#123;“张三丰”,“宋远桥”,“张无忌”,“殷梨亭”“张翠山”,“莫声谷”&#125;，将数组中的元素添加到集合中，并把所有姓张的人员打印到控制台上2.3.2.1 案例代码六:package com.itheima_02;import java.util.ArrayList;&#x2F;* * 给定一个字符串数组：&#123;“张三丰”,“宋远桥”,“张无忌”,“殷梨亭”,“张翠山”,“莫声谷”&#125;，将数组中的元素添加到集合中，并把所有姓张的人员打印到控制台上。 * * 分析： * A:定义字符串数组 * B:创建集合对象 * C:遍历字符串数组，获取到每一个字符串元素 * D:把获取到的字符串元素添加到集合 * E:遍历集合 * 要判断每一个字符串元素是否以&quot;张&quot;开头，如果是，就输出在控制台 *&#x2F;public class ArrayListTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义字符串数组 String[] strArray &#x3D; &#123;&quot;张三丰&quot;,&quot;宋远桥&quot;,&quot;张无忌&quot;,&quot;殷梨亭&quot;,&quot;张翠山&quot;,&quot;莫声谷&quot;&#125;; &#x2F;&#x2F;创建集合对象 ArrayList&lt;String&gt; array &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;遍历字符串数组，获取到每一个字符串元素 for(int x&#x3D;0; x&lt;strArray.length; x++) &#123; &#x2F;&#x2F;把获取到的字符串元素添加到集合 array.add(strArray[x]); &#125; &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; String s &#x3D; array.get(x); &#x2F;&#x2F;要判断每一个字符串元素是否以&quot;张&quot;开头，如果是，就输出在控制台 if(s.startsWith(&quot;张&quot;)) &#123; System.out.println(s); &#125; &#125; &#125;&#125;2.3.3 ArrayList练习之存储自定义对象并遍历 A:自定义一个学生类,学生中有姓名和年龄属性,生成满参构造与空参构造生成属性对应的getter&#x2F;setter方法B:在测试类中使用满参构造创建三个学生对象,然后将每个学生对象均添加到ArrayList集合中C:遍历这个ArrayList集合,依次打印出每个学生的姓名和年龄2.3.3.1 案例代码七:package com.itheima_02;public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125;package com.itheima_02;import java.util.ArrayList;&#x2F;* * 存储自定义对象并遍历 * * 分析： * A:定义学生类 * B:创建集合对象 * C:创建学生对象 * D:把学生对象作为元素添加到集合中 * E:遍历集合 *&#x2F;public class ArrayListTest3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;&#x2F;创建学生对象 Student s1 &#x3D; new Student(&quot;林青霞&quot;,28); Student s2 &#x3D; new Student(&quot;张曼玉&quot;,30); Student s3 &#x3D; new Student(&quot;景甜&quot;,25); Student s4 &#x3D; new Student(&quot;柳岩&quot;,18); &#x2F;&#x2F;把学生对象作为元素添加到集合中 array.add(s1); array.add(s2); array.add(s3); array.add(s4); &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; Student s &#x3D; array.get(x); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125;&#125;2.3.4 ArrayList练习之键盘录入数据存储并遍历 创建一个Student类包含姓名和年龄属性创建一个ArrayList集合 向集合中添加三个Student对象Student对象中姓名和年龄的数据均来自与键盘录入 最终遍历这个集合,取出Student对象以及里面属性的值2.3.4.1 案例代码八:package com.itheima_03;public class Student &#123; private String name; private String age; public Student() &#123; &#125; public Student(String name, String age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age &#x3D; age; &#125;&#125;package com.itheima_03;import java.util.ArrayList;import java.util.Scanner;&#x2F;* * 创建一个集合，存储学生对象，学生对象的数据来自于键盘录入，最后，遍历集合 * * 注意：为了方便使用，我把学生类中的所有成员定义为String类型 * * 分析： * A:定义学生类 * B:创建集合对象 * C:键盘录入数据,创建学生对象,把键盘录入的数据赋值给学生对象的成员变量 * D:把学生对象作为元素存储到集合中 * E:遍历集合 * *&#x2F;public class StudentDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;* &#x2F;&#x2F;键盘录入数据,创建学生对象,把键盘录入的数据赋值给学生对象的成员变量 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入学生姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生年龄：&quot;); String age &#x3D; sc.nextLine(); Student s &#x3D; new Student(); s.setName(name); s.setAge(age); &#x2F;&#x2F;把学生对象作为元素存储到集合中 array.add(s); *&#x2F; &#x2F;&#x2F;为了提高代码的复用性，我把键盘录入数据给学生对象，并存储到集合中的动作用一个方法来实现 &#x2F;&#x2F;调用方法 addStudent(array); addStudent(array); addStudent(array); &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; Student s &#x3D; array.get(x); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125; &#x2F;* * 两个明确： * 返回值类型：void * 参数列表：ArrayList&lt;Student&gt; array *&#x2F; public static void addStudent(ArrayList&lt;Student&gt; array) &#123; &#x2F;&#x2F;键盘录入数据,创建学生对象,把键盘录入的数据赋值给学生对象的成员变量 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入学生姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生年龄：&quot;); String age &#x3D; sc.nextLine(); Student s &#x3D; new Student(); s.setName(name); s.setAge(age); &#x2F;&#x2F;把学生对象作为元素存储到集合中 array.add(s); &#125;&#125;第3章 学生管理系统案例3.1 学生管理系统案例需求 利用集合完成对学生的增删改查四个功能3.2 学生管理系统案例实现3.2.1 创建学生类:3.2.1.1 案例代码九:package com.itheima;&#x2F;* * 这是我的学生类 *&#x2F;public class Student &#123; &#x2F;&#x2F;学号 private String id; &#x2F;&#x2F;姓名 private String name; &#x2F;&#x2F;年龄 private String age; &#x2F;&#x2F;居住地 private String address; public Student() &#123; &#125; public Student(String id, String name, String age, String address) &#123; this.id &#x3D; id; this.name &#x3D; name; this.age &#x3D; age; this.address &#x3D; address; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id &#x3D; id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age &#x3D; age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address &#x3D; address; &#125;&#125;3.2.2 学生管理系统界面实现:3.2.2.1 案例代码十:package com.itheima;import java.util.ArrayList;import java.util.Scanner;&#x2F;* * 这是我的学生管理系统的主类 * * 步骤如下： * A:定义学生类 * B:学生管理系统的主界面的代码编写 * C:学生管理系统的查看所有学生的代码编写 * D:学生管理系统的添加学生的代码编写 * E:学生管理系统的删除学生的代码编写 * F:学生管理系统的修改学生的代码编写 *&#x2F;public class StudentManagerTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 创建集合对象，用于存储学生数据 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;&#x2F; 为了让程序能够回到这里来，我们使用循环 while (true) &#123; &#x2F;&#x2F; 这是学生管理系统的主界面 System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); &#x2F;&#x2F; 创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); String choiceString &#x3D; sc.nextLine(); &#x2F;&#x2F; 用switch语句实现选择 switch (choiceString) &#123; case &quot;1&quot;: &#x2F;&#x2F; 查看所有学生 break; case &quot;2&quot;: &#x2F;&#x2F; 添加学生 break; case &quot;3&quot;: &#x2F;&#x2F; 删除学生 break; case &quot;4&quot;: &#x2F;&#x2F; 修改学生 break; case &quot;5&quot;: &#x2F;&#x2F; 退出 &#x2F;&#x2F; System.out.println(&quot;谢谢你的使用&quot;); &#x2F;&#x2F; break; default: System.out.println(&quot;谢谢你的使用&quot;); System.exit(0); &#x2F;&#x2F; JVM退出 break; &#125; &#125; &#125;&#125;3.2.3 学生管理系统之查询所有学生功能3.2.3.1 案例代码十一:package com.itheima.test;import java.util.ArrayList;import java.util.Scanner;&#x2F;* * 这是我的学生管理系统的主类 * * 步骤如下： * A:定义学生类 * B:学生管理系统的主界面的代码编写 * C:学生管理系统的查看所有学生的代码编写 * D:学生管理系统的添加学生的代码编写 * E:学生管理系统的删除学生的代码编写 * F:学生管理系统的修改学生的代码编写 *&#x2F;public class StudentManagerTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象，用于存储学生数据 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;&#x2F;为了让程序能够回到这里来，我们使用循环 while(true) &#123; &#x2F;&#x2F;这是学生管理系统的主界面 System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); String choiceString &#x3D; sc.nextLine(); &#x2F;&#x2F;用switch语句实现选择 switch(choiceString) &#123; case &quot;1&quot;: &#x2F;&#x2F;查看所有学生 findAllStudent(array); break; case &quot;2&quot;: &#x2F;&#x2F;添加学生 break; case &quot;3&quot;: &#x2F;&#x2F;删除学生 break; case &quot;4&quot;: &#x2F;&#x2F;修改学生 break; case &quot;5&quot;: &#x2F;&#x2F;退出 &#x2F;&#x2F;System.out.println(&quot;谢谢你的使用&quot;); &#x2F;&#x2F;break; default: System.out.println(&quot;谢谢你的使用&quot;); System.exit(0); &#x2F;&#x2F;JVM退出 break; &#125; &#125; &#125; &#x2F;&#x2F;查看所有学生 public static void findAllStudent(ArrayList&lt;Student&gt; array) &#123; &#x2F;&#x2F;首先来判断集合中是否有数据，如果没有数据，就给出提示，并让该方法不继续往下执行 if(array.size() &#x3D;&#x3D; 0) &#123; System.out.println(&quot;不好意思,目前没有学生信息可供查询,请回去重新选择你的操作&quot;); return; &#x2F;&#x2F;return 并让该方法不继续往下执行，在这里停住 &#125; &#x2F;&#x2F;\\t 其实就是一个tab键的位置 System.out.println(&quot;学号\\t\\t姓名\\t年龄\\t居住地&quot;); for(int x&#x3D;0; x&lt;array.size(); x++) &#123; Student s &#x3D; array.get(x); System.out.println(s.getId()+&quot;\\t&quot;+s.getName()+&quot;\\t&quot;+s.getAge()+&quot;\\t&quot;+s.getAddress()); &#125; &#125;&#125;3.2.4 学生管理系统之添加学生功能3.2.4.1 案例代码十二:package com.itheima;import java.util.ArrayList;import java.util.Scanner;&#x2F;* * 这是我的学生管理系统的主类 * * 步骤如下： * A:定义学生类 * B:学生管理系统的主界面的代码编写 * C:学生管理系统的查看所有学生的代码编写 * D:学生管理系统的添加学生的代码编写 * E:学生管理系统的删除学生的代码编写 * F:学生管理系统的修改学生的代码编写 *&#x2F;public class StudentManagerTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象，用于存储学生数据 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;&#x2F;为了让程序能够回到这里来，我们使用循环 while(true) &#123; &#x2F;&#x2F;这是学生管理系统的主界面 System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); String choiceString &#x3D; sc.nextLine(); &#x2F;&#x2F;用switch语句实现选择 switch(choiceString) &#123; case &quot;1&quot;: &#x2F;&#x2F;查看所有学生 break; case &quot;2&quot;: &#x2F;&#x2F;添加学生 addStudent(array); break; case &quot;3&quot;: &#x2F;&#x2F;删除学生 break; case &quot;4&quot;: &#x2F;&#x2F;修改学生 break; case &quot;5&quot;: &#x2F;&#x2F;退出 &#x2F;&#x2F;System.out.println(&quot;谢谢你的使用&quot;); &#x2F;&#x2F;break; default: System.out.println(&quot;谢谢你的使用&quot;); System.exit(0); &#x2F;&#x2F;JVM退出 break; &#125; &#125; &#125; &#x2F;* &#x2F;&#x2F;添加学生 public static void addStudent(ArrayList&lt;Student&gt; array) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入学生学号：&quot;); String id &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生年龄：&quot;); String age &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生居住地：&quot;); String address &#x3D; sc.nextLine(); &#x2F;&#x2F;创建学生对象 Student s &#x3D; new Student(); s.setId(id); s.setName(name); s.setAge(age); s.setAddress(address); &#x2F;&#x2F;把学生对象作为元素添加到集合 array.add(s); &#x2F;&#x2F;给出提示 System.out.println(&quot;添加学生成功&quot;); &#125; *&#x2F; &#x2F;&#x2F;添加学生 public static void addStudent(ArrayList&lt;Student&gt; array) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;为了让id能够被访问到，我们就把id定义在了循环的外面 String id; &#x2F;&#x2F;为了让代码能够回到这里，用循环 while(true) &#123; System.out.println(&quot;请输入学生学号：&quot;); &#x2F;&#x2F;String id &#x3D; sc.nextLine(); id &#x3D; sc.nextLine(); &#x2F;&#x2F;判断学号有没有被人占用 &#x2F;&#x2F;定义标记 boolean flag &#x3D; false; &#x2F;&#x2F;遍历集合，得到每一个学生 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; Student s &#x3D; array.get(x); &#x2F;&#x2F;获取该学生的学号，和键盘录入的学号进行比较 if(s.getId().equals(id)) &#123; flag &#x3D; true; &#x2F;&#x2F;说明学号被占用了 break; &#125; &#125; if(flag) &#123; System.out.println(&quot;你输入的学号已经被占用,请重新输入&quot;); &#125;else &#123; break; &#x2F;&#x2F;结束循环 &#125; &#125; System.out.println(&quot;请输入学生姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生年龄：&quot;); String age &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生居住地：&quot;); String address &#x3D; sc.nextLine(); &#x2F;&#x2F;创建学生对象 Student s &#x3D; new Student(); s.setId(id); s.setName(name); s.setAge(age); s.setAddress(address); &#x2F;&#x2F;把学生对象作为元素添加到集合 array.add(s); &#x2F;&#x2F;给出提示 System.out.println(&quot;添加学生成功&quot;); &#125;&#125;3.2.5 学生管理系统之删除学生功能3.2.5.1 案例代码十三:package com.itheima;import java.util.ArrayList;import java.util.Scanner;&#x2F;* * 这是我的学生管理系统的主类 * * 步骤如下： * A:定义学生类 * B:学生管理系统的主界面的代码编写 * C:学生管理系统的查看所有学生的代码编写 * D:学生管理系统的添加学生的代码编写 * E:学生管理系统的删除学生的代码编写 * F:学生管理系统的修改学生的代码编写 *&#x2F;public class StudentManagerTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象，用于存储学生数据 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;&#x2F;为了让程序能够回到这里来，我们使用循环 while(true) &#123; &#x2F;&#x2F;这是学生管理系统的主界面 System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); String choiceString &#x3D; sc.nextLine(); &#x2F;&#x2F;用switch语句实现选择 switch(choiceString) &#123; case &quot;1&quot;: &#x2F;&#x2F;查看所有学生 break; case &quot;2&quot;: &#x2F;&#x2F;添加学生 break; case &quot;3&quot;: &#x2F;&#x2F;删除学生 deleteStudent(array); break; case &quot;4&quot;: &#x2F;&#x2F;修改学生 break; case &quot;5&quot;: &#x2F;&#x2F;退出 &#x2F;&#x2F;System.out.println(&quot;谢谢你的使用&quot;); &#x2F;&#x2F;break; default: System.out.println(&quot;谢谢你的使用&quot;); System.exit(0); &#x2F;&#x2F;JVM退出 break; &#125; &#125; &#125; &#x2F;&#x2F;删除学生 public static void deleteStudent(ArrayList&lt;Student&gt; array) &#123; &#x2F;&#x2F;删除学生的思路：键盘录入一个学号，到集合中去查找，看是否有学生使用的是该学号，如果有就删除该学生 &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入你要删除的学生的学号：&quot;); String id &#x3D; sc.nextLine(); &#x2F;* &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; &#x2F;&#x2F;获取到每一个学生对象 Student s &#x3D; array.get(x); &#x2F;&#x2F;拿这个学生对象的学号和键盘录入的学号进行比较 if(s.getId().equals(id)) &#123; array.remove(x); &#x2F;&#x2F;根据索引删除 break; &#125; &#125; &#x2F;&#x2F;给出提示 System.out.println(&quot;删除学生成功&quot;); *&#x2F; &#x2F;&#x2F;我们必须给出学号不存在的时候的提示 &#x2F;&#x2F;定义一个索引 int index &#x3D; -1; &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; &#x2F;&#x2F;获取到每一个学生对象 Student s &#x3D; array.get(x); &#x2F;&#x2F;拿这个学生对象的学号和键盘录入的学号进行比较 if(s.getId().equals(id)) &#123; index &#x3D; x; break; &#125; &#125; if(index &#x3D;&#x3D; -1) &#123; System.out.println(&quot;不好意思,你要删除的学号对应的学生信息不存在,请回去重新你的选择&quot;); &#125;else &#123; array.remove(index); System.out.println(&quot;删除学生成功&quot;); &#125; &#125;&#125;3.2.6 学生管理系统之修改学生功能3.2.6.1 案例代码十四:package com.itheima;import java.util.ArrayList;import java.util.Scanner;&#x2F;* * 这是我的学生管理系统的主类 * * 步骤如下： * A:定义学生类 * B:学生管理系统的主界面的代码编写 * C:学生管理系统的查看所有学生的代码编写 * D:学生管理系统的添加学生的代码编写 * E:学生管理系统的删除学生的代码编写 * F:学生管理系统的修改学生的代码编写 *&#x2F;public class StudentManagerTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建集合对象，用于存储学生数据 ArrayList&lt;Student&gt; array &#x3D; new ArrayList&lt;Student&gt;(); &#x2F;&#x2F;为了让程序能够回到这里来，我们使用循环 while(true) &#123; &#x2F;&#x2F;这是学生管理系统的主界面 System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); String choiceString &#x3D; sc.nextLine(); &#x2F;&#x2F;用switch语句实现选择 switch(choiceString) &#123; case &quot;1&quot;: &#x2F;&#x2F;查看所有学生 break; case &quot;2&quot;: &#x2F;&#x2F;添加学生 break; case &quot;3&quot;: &#x2F;&#x2F;删除学生 break; case &quot;4&quot;: &#x2F;&#x2F;修改学生 updateStudent(array); break; case &quot;5&quot;: &#x2F;&#x2F;退出 &#x2F;&#x2F;System.out.println(&quot;谢谢你的使用&quot;); &#x2F;&#x2F;break; &#x2F;&#x2F;case穿透，输入5会继续往下执行 default: System.out.println(&quot;谢谢你的使用&quot;); System.exit(0); &#x2F;&#x2F;JVM退出 break; &#125; &#125; &#125; &#x2F;&#x2F;修改学生 public static void updateStudent(ArrayList&lt;Student&gt; array) &#123; &#x2F;&#x2F;修改学生的思路：键盘录入一个学号，到集合中去查找，看是否有学生使用的是该学号，如果有就修改该学生 &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入你要修改的学生的学号：&quot;); String id &#x3D; sc.nextLine(); &#x2F;&#x2F;定义一个索引 int index &#x3D; -1; &#x2F;&#x2F;遍历集合 for(int x&#x3D;0; x&lt;array.size(); x++) &#123; &#x2F;&#x2F;获取每一个学生对象 Student s &#x3D; array.get(x); &#x2F;&#x2F;拿学生对象的学号和键盘录入的学号进行比较 if(s.getId().equals(id)) &#123; index &#x3D; x; break; &#125; &#125; if(index &#x3D;&#x3D; -1) &#123; System.out.println(&quot;不好意思,你要修改的学号对应的学生信息不存在,请回去重新你的选择&quot;); &#125;else &#123; System.out.println(&quot;请输入学生新姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生新年龄：&quot;); String age &#x3D; sc.nextLine(); System.out.println(&quot;请输入学生新居住地：&quot;); String address &#x3D; sc.nextLine(); &#x2F;&#x2F;创建学生对象 Student s &#x3D; new Student(); s.setId(id); s.setName(name); s.setAge(age); s.setAddress(address); &#x2F;&#x2F;修改集合中的学生对象 array.set(index, s); &#x2F;&#x2F;给出提示 System.out.println(&quot;修改学生成功&quot;); &#125; &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"03-常用API","slug":"Note-Collections/JavaEE-学习笔记/03-常用API","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03-%E5%B8%B8%E7%94%A8API/"}]},{"title":"","date":"2019-09-19T00:06:58.640Z","path":"wiki/Note Collections/JavaEE 学习笔记/03-常用API/01-API-StringBuilder/","text":"API-StringBuilder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833今日内容介绍 API概述 Scanner类与String类 StringBuilder类第1章 API概述1.1 API概念API(Application Programming Interface) : 应用程序编程接口编写一个机器人程序去控制机器人踢足球，程序就需要向机器人发出向前跑、向后跑、射门、抢球等各种命令，没有编过程序的人很难想象这样的程序如何编写。但是对于有经验的开发人员来说，知道机器人厂商一定会提供一些用于控制机器人的Java类，这些类中定义好了操作机器人各种动作的方法。其实，这些Java类就是机器人厂商提供给应用程序编程的接口，大家把这些类称为API。本章涉及的Java API指的就是JDK中提供的各种功能的Java类1.2 快速使用API步骤:A:打开帮助文档B:点击显示，找到索引，看到输入框C:你要学习什么内容，你就在框框里面输入什么内容 举例：RandomD:看包java.lang包下的类在使用的时候是不需要导包的E:看类的描述 Random类是用于生成随机数的类F:看构造方法 Random():无参构造方法 Random r &#x3D; new Random();G:看成员方法 public int nextInt(int n):产生的是一个[0,n)范围内的随机数 调用方法： 看返回值类型：人家返回什么类型，你就用什么类型接收 看方法名：名字不要写错了 看形式参数：人家要几个参数，你就给几个，人家要什么数据类型的，你就给什么数据类型的 int number &#x3D; r.nextInt(100);第2章 Scanner类 与 String类2.1 Scanner类2.1.1 Scanner类作用 用Scanner类的方法可以完成接收键盘录入的数据2.1.2 Scanner类接受键盘录入的字符串2.1.2.1 案例代码一:package com.itheima_01;import java.util.Scanner;&#x2F;* * Scanner:用于获取键盘录入的数据。(基本数据类型，字符串数据) * public String nextLine():获取键盘录入的字符串数据 *&#x2F;public class ScannerDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入一个字符串数据：&quot;); String s &#x3D; sc.nextLine(); &#x2F;&#x2F;输出结果 System.out.println(&quot;s:&quot;+s); &#125;&#125;2.2 String类2.2.1 String类概述通过JDK提供的API，查看String类的说明A:&quot;abc&quot;是String类的一个实例,或者成为String类的一个对象B:字符串字面值&quot;abc&quot;也可以看成是一个字符串对象C:字符串是常量，一旦被赋值，就不能被改变D:字符串本质是一个字符数组2.2.2 String类的构造方法 String(String original):把字符串数据封装成字符串对象 String(char[] value):把字符数组的数据封装成字符串对象 String(char[] value, int index, int count):把字符数组中的一部分数据封装成字符串对象2.2.2.1 常用构造方法演示2.2.2.1.1 案例代码二:package com.itheima_02;&#x2F;* * String:字符串类 * 由多个字符组成的一串数据 * 字符串其本质是一个字符数组 * * 构造方法： * String(String original):把字符串数据封装成字符串对象 * String(char[] value):把字符数组的数据封装成字符串对象 * String(char[] value, int index, int count):把字符数组中的一部分数据封装成字符串对象 * * 注意：字符串是一种比较特殊的引用数据类型，直接输出字符串对象输出的是该对象中的数据。 *&#x2F;public class StringDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;方式1 &#x2F;&#x2F;String(String original):把字符串数据封装成字符串对象 String s1 &#x3D; new String(&quot;hello&quot;); System.out.println(&quot;s1:&quot;+s1); System.out.println(&quot;---------&quot;); &#x2F;&#x2F;方式2 &#x2F;&#x2F;String(char[] value):把字符数组的数据封装成字符串对象 char[] chs &#x3D; &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;; String s2 &#x3D; new String(chs); System.out.println(&quot;s2:&quot;+s2); System.out.println(&quot;---------&quot;); &#x2F;&#x2F;方式3 &#x2F;&#x2F;String(char[] value, int index, int count):把字符数组中的一部分数据封装成字符串对象 &#x2F;&#x2F;String s3 &#x3D; new String(chs,0,chs.length); String s3 &#x3D; new String(chs,1,3); System.out.println(&quot;s3:&quot;+s3); System.out.println(&quot;---------&quot;); &#x2F;&#x2F;方式4 String s4 &#x3D; &quot;hello&quot;; System.out.println(&quot;s4:&quot;+s4); &#125;&#125;2.2.2.2 创建字符串对象两种方式的区别2.2.2.2.1 案例代码三:package com.itheima_02;&#x2F;* * 通过构造方法创建的字符串对象和直接赋值方式创建的字符串对象有什么区别呢? * 通过构造方法创建字符串对象是在堆内存。 * 直接赋值方式创建对象是在方法区的常量池。 * * &#x3D;&#x3D;: * 基本数据类型：比较的是基本数据类型的值是否相同 * 引用数据类型：比较的是引用数据类型的地址值是否相同 *&#x2F;public class StringDemo2 &#123; public static void main(String[] args) &#123; String s1 &#x3D; new String(&quot;hello&quot;); String s2 &#x3D; &quot;hello&quot;; System.out.println(&quot;s1:&quot;+s1); System.out.println(&quot;s2:&quot;+s2); System.out.println(&quot;s1&#x3D;&#x3D;s2:&quot;+(s1&#x3D;&#x3D;s2)); &#x2F;&#x2F;false String s3 &#x3D; &quot;hello&quot;; System.out.println(&quot;s1&#x3D;&#x3D;s3:&quot;+(s1&#x3D;&#x3D;s3)); &#x2F;&#x2F;false System.out.println(&quot;s2&#x3D;&#x3D;s3:&quot;+(s2&#x3D;&#x3D;s3)); &#x2F;&#x2F;true &#125;&#125;2.2.3 String类的判断功能boolean equals(Object obj):比较字符串的内容是否相同 boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 boolean startsWith(String str):判断字符串对象是否以指定的str开头 boolean endsWith(String str):判断字符串对象是否以指定的str结尾2.2.3.1 判断方法演示2.2.3.1.1 案例代码四:package com.itheima_03;&#x2F;* * Object:是类层次结构中的根类，所有的类都直接或者间接的继承自该类。 * 如果一个方法的形式参数是Object，那么这里我们就可以传递它的任意的子类对象。 * * String类的判断功能： * boolean equals(Object obj):比较字符串的内容是否相同 * boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 * boolean startsWith(String str):判断字符串对象是否以指定的str开头 * boolean endsWith(String str):判断字符串对象是否以指定的str结尾 *&#x2F;public class StringDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建字符串对象 String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;hello&quot;; String s3 &#x3D; &quot;Hello&quot;; &#x2F;&#x2F;boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); System.out.println(&quot;-----------&quot;); &#x2F;&#x2F;boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); System.out.println(s1.equalsIgnoreCase(s3)); System.out.println(&quot;-----------&quot;); &#x2F;&#x2F;boolean startsWith(String str):判断字符串对象是否以指定的str开头 System.out.println(s1.startsWith(&quot;he&quot;)); System.out.println(s1.startsWith(&quot;ll&quot;)); &#125;&#125;2.2.3.2 判断功能案例需求:模拟登录,给三次机会,并提示还有几次2.2.3.2.1 案例代码五:package com.itheima_03;import java.util.Scanner;&#x2F;* * 模拟登录,给三次机会,并提示还有几次。 * * 分析： * A:定义两个字符串对象，用于存储已经存在的用户名和密码 * B:键盘录入用户名和密码 * C:拿键盘录入的用户名和密码和已经存在的用户名和密码进行比较 * 如果内容相同，提示登录成功 * 如果内容不同，提示登录失败，并提示还有几次机会 *&#x2F;public class StringTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义两个字符串对象，用于存储已经存在的用户名和密码 String username &#x3D; &quot;admin&quot;; String password &#x3D; &quot;admin&quot;; &#x2F;&#x2F;给三次机会，用for循环实现 for(int x&#x3D;0; x&lt;3; x++) &#123; &#x2F;&#x2F;键盘录入用户名和密码 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String pwd &#x3D; sc.nextLine(); &#x2F;&#x2F;拿键盘录入的用户名和密码和已经存在的用户名和密码进行比较 if(username.equals(name) &amp;&amp; password.equals(pwd)) &#123; System.out.println(&quot;登录成功&quot;); break; &#125;else &#123; if((2-x) &#x3D;&#x3D;0) &#123; System.out.println(&quot;用户名和密码被锁定,请与管理员联系&quot;); &#125;else &#123; System.out.println(&quot;登录失败,你还有&quot;+(2-x)+&quot;次机会&quot;); &#x2F;&#x2F;2,1,0 &#125; &#125; &#125; &#125;&#125;2.2.4 String类的获取功能2.2.4.1 获取方法演示package com.itheima_04;&#x2F;* * String类的获取功能： * int length():获取字符串的长度，其实也就是字符个数 * char charAt(int index):获取指定索引处的字符 * int indexOf(String str):获取str在字符串对象中第一次出现的索引 * String substring(int start):从start开始截取字符串 * String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end *&#x2F;public class StringDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建字符串对象 String s &#x3D; &quot;helloworld&quot;; &#x2F;&#x2F;int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length()); System.out.println(&quot;--------&quot;); &#x2F;&#x2F;char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;--------&quot;); &#x2F;&#x2F;int indexOf(String str):获取str在字符串对象中第一次出现的索引 System.out.println(s.indexOf(&quot;l&quot;)); System.out.println(s.indexOf(&quot;owo&quot;)); System.out.println(s.indexOf(&quot;ak&quot;)); System.out.println(&quot;--------&quot;); &#x2F;&#x2F;String substring(int start):从start开始截取字符串 System.out.println(s.substring(0)); System.out.println(s.substring(5)); System.out.println(&quot;--------&quot;); &#x2F;&#x2F;String substring(int start,int end):从start开始，到end结束截取字符串 System.out.println(s.substring(0, s.length())); System.out.println(s.substring(3,8)); &#125;&#125;2.2.4.2 获取功能案例2.2.4.2.1 案例代码六:package com.itheima_04;&#x2F;* * 遍历字符串(获取字符串中的每一个字符) *&#x2F;public class StringTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建一个字符串对象 String s &#x3D; &quot;abcde&quot;; &#x2F;&#x2F;原始做法 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(s.charAt(2)); System.out.println(s.charAt(3)); System.out.println(s.charAt(4)); System.out.println(&quot;---------&quot;); &#x2F;&#x2F;用for循环改进 for(int x&#x3D;0; x&lt;5; x++) &#123; System.out.println(s.charAt(x)); &#125; System.out.println(&quot;---------&quot;); &#x2F;&#x2F;用length()方法获取字符串的长度 for(int x&#x3D;0; x&lt;s.length(); x++) &#123; System.out.println(s.charAt(x)); &#125; &#125;&#125;2.2.4.2.2 案例代码七:package com.itheima_04;import java.util.Scanner;&#x2F;* * 统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) * * 分析： * A:键盘录入一个字符串数据 * B:定义三个统计变量，初始化值都是0 * C:遍历字符串，得到每一个字符 * D:拿字符进行判断 * 假如ch是一个字符。 * 大写：ch&gt;&#x3D;&#39;A&#39; &amp;&amp; ch&lt;&#x3D;&#39;Z&#39; * 小写：ch&gt;&#x3D;&#39;a&#39; &amp;&amp; ch&lt;&#x3D;&#39;z&#39; * 数字：ch&gt;&#x3D;&#39;0&#39; &amp;&amp; ch&lt;&#x3D;&#39;9&#39; * E:输出结果 *&#x2F;public class StringTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个字符串数据 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入一个字符串数据：&quot;); String s &#x3D; sc.nextLine(); &#x2F;&#x2F;定义三个统计变量，初始化值都是0 int bigCount &#x3D; 0; int smallCount &#x3D; 0; int numberCount &#x3D; 0; &#x2F;&#x2F;遍历字符串，得到每一个字符 for(int x&#x3D;0; x&lt;s.length(); x++) &#123; char ch &#x3D; s.charAt(x); &#x2F;&#x2F;拿字符进行判断 if(ch&gt;&#x3D;&#39;A&#39; &amp;&amp; ch&lt;&#x3D;&#39;Z&#39;) &#123; bigCount++; &#125;else if(ch&gt;&#x3D;&#39;a&#39; &amp;&amp; ch&lt;&#x3D;&#39;z&#39;) &#123; smallCount++; &#125;else if(ch&gt;&#x3D;&#39;0&#39; &amp;&amp; ch&lt;&#x3D;&#39;9&#39;) &#123; numberCount++; &#125;else &#123; System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); &#125; &#125; &#x2F;&#x2F;输出结果 System.out.println(&quot;大写字符：&quot;+bigCount+&quot;个&quot;); System.out.println(&quot;小写字符：&quot;+smallCount+&quot;个&quot;); System.out.println(&quot;数字字符：&quot;+numberCount+&quot;个&quot;); &#125;&#125;2.2.5 String类的转换功能2.2.5.1 转换方法演示char[] toCharArray():把字符串转换为字符数组String toLowerCase():把字符串转换为小写字符串String toUpperCase():把字符串转换为大写字符串2.2.5.1.1 案例代码八:package com.itheima_05;&#x2F;* * String类的转换功能： * char[] toCharArray():把字符串转换为字符数组 * String toLowerCase():把字符串转换为小写字符串 * String toUpperCase():把字符串转换为大写字符串 * * 字符串的遍历： * A:length()加上charAt() * B:把字符串转换为字符数组，然后遍历数组 *&#x2F;public class StringDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建字符串对象 String s &#x3D; &quot;abcde&quot;; &#x2F;&#x2F;char[] toCharArray():把字符串转换为字符数组 char[] chs &#x3D; s.toCharArray(); for(int x&#x3D;0; x&lt;chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println(&quot;-----------&quot;); &#x2F;&#x2F;String toLowerCase():把字符串转换为小写字符串 System.out.println(&quot;HelloWorld&quot;.toLowerCase()); &#x2F;&#x2F;String toUpperCase():把字符串转换为大写字符串 System.out.println(&quot;HelloWorld&quot;.toUpperCase()); &#125;&#125;2.2.5.2 转换功能案例2.2.5.2.1 案例代码九:package com.itheima_05;import java.util.Scanner;&#x2F;* * 键盘录入一个字符串，把该字符串的首字母转成大写，其余为小写。(只考虑英文大小写字母字符) * * 分析： * A:键盘录入一个字符串 * B:截取首字母 * C:截取除了首字母以外的字符串 * D:B转大写+C转小写 * E:输出即可 *&#x2F;public class StringTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个字符串 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s &#x3D; sc.nextLine(); &#x2F;&#x2F;截取首字母 String s1 &#x3D; s.substring(0, 1); &#x2F;&#x2F;截取除了首字母以外的字符串 String s2 &#x3D; s.substring(1); &#x2F;&#x2F;B转大写+C转小写 String s3 &#x3D; s1.toUpperCase()+s2.toLowerCase(); &#x2F;&#x2F;输出即可 System.out.println(&quot;s3:&quot;+s3); &#125;&#125;2.2.6 String类的其它功能2.2.6.1 其它方法演示2.2.6.1.1 案例代码十:package com.itheima_06;&#x2F;* * 去除字符串两端空格 * String trim() * 按照指定符号分割字符串 * String[] split(String str) *&#x2F;public class StringDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建字符串对象 String s1 &#x3D; &quot;helloworld&quot;; String s2 &#x3D; &quot; helloworld &quot;; String s3 &#x3D; &quot; hello world &quot;; System.out.println(&quot;---&quot;+s1+&quot;---&quot;); System.out.println(&quot;---&quot;+s1.trim()+&quot;---&quot;); System.out.println(&quot;---&quot;+s2+&quot;---&quot;); System.out.println(&quot;---&quot;+s2.trim()+&quot;---&quot;); System.out.println(&quot;---&quot;+s3+&quot;---&quot;); System.out.println(&quot;---&quot;+s3.trim()+&quot;---&quot;); System.out.println(&quot;-------------------&quot;); &#x2F;&#x2F;String[] split(String str) &#x2F;&#x2F;创建字符串对象 String s4 &#x3D; &quot;aa,bb,cc&quot;; String[] strArray &#x3D; s4.split(&quot;,&quot;); for(int x&#x3D;0; x&lt;strArray.length; x++) &#123; System.out.println(strArray[x]); &#125; &#125;&#125;2.2.7 String类的其它案例2.2.7.1 案例代码十一:package com.itheima_07;&#x2F;* * 把数组中的数据按照指定个格式拼接成一个字符串 * 举例：int[] arr &#x3D; &#123;1,2,3&#125;; * 输出结果：[1, 2, 3] * * 分析： * A:定义一个int类型的数组 * B:写方法实现把数组中的元素按照指定的格式拼接成一个字符串 * C:调用方法 * D:输出结果 *&#x2F;public class StringTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义一个int类型的数组 int[] arr &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F;写方法实现把数组中的元素按照指定的格式拼接成一个字符串 &#x2F;&#x2F;调用方法 String s &#x3D; arrayToString(arr); &#x2F;&#x2F;输出结果 System.out.println(&quot;s:&quot;+s); &#125; &#x2F;* * 两个明确： * 返回值类型：String * 参数列表：int[] arr *&#x2F; public static String arrayToString(int[] arr) &#123; String s &#x3D; &quot;&quot;; &#x2F;&#x2F;[1, 2, 3] s +&#x3D; &quot;[&quot;; for(int x&#x3D;0; x&lt;arr.length; x++) &#123; if(x&#x3D;&#x3D;arr.length-1) &#123; s +&#x3D; arr[x]; &#125;else &#123; s +&#x3D; arr[x]; s +&#x3D; &quot;, &quot;; &#125; &#125; s +&#x3D; &quot;]&quot;; return s; &#125;&#125;2.2.7.2 案例代码十二:package com.itheima_07;import java.util.Scanner;&#x2F;* * 字符串反转 * 举例：键盘录入”abc” * 输出结果：”cba” * * 分析： * A:键盘录入一个字符串 * B:写方法实现字符串的反转 * a:把字符串倒着遍历，得到的每一个字符拼接成字符串。 * b:把字符串转换为字符数组，然后对字符数组进行反转，最后在把字符数组转换为字符串 * C:调用方法 * D:输出结果 *&#x2F;public class StringTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个字符串 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s &#x3D; sc.nextLine(); &#x2F;&#x2F;写方法实现字符串的反转 &#x2F;&#x2F;调用方法 String result &#x3D; reverse(s); &#x2F;&#x2F;输出结果 System.out.println(&quot;result:&quot;+result); &#125; &#x2F;* * 把字符串倒着遍历，得到的每一个字符拼接成字符串。 * * 两个明确： * 返回值类型：String * 参数列表：String s *&#x2F; &#x2F;* public static String reverse(String s) &#123; String ss &#x3D; &quot;&quot;; for(int x&#x3D;s.length()-1; x&gt;&#x3D;0; x--) &#123; ss +&#x3D; s.charAt(x); &#125; return ss; &#125; *&#x2F; &#x2F;&#x2F;把字符串转换为字符数组，然后对字符数组进行反转，最后在把字符数组转换为字符串 public static String reverse(String s) &#123; &#x2F;&#x2F;把字符串转换为字符数组 char[] chs &#x3D; s.toCharArray(); &#x2F;&#x2F;对字符数组进行反转 for(int start&#x3D;0,end&#x3D;chs.length-1; start&lt;&#x3D;end; start++,end--) &#123; char temp &#x3D; chs[start]; chs[start] &#x3D; chs[end]; chs[end] &#x3D; temp; &#125; &#x2F;&#x2F;最后在把字符数组转换为字符串 String ss &#x3D; new String(chs); return ss; &#125;&#125;第3章 StringBuilder类3.1 StringBuilder类概述 StringBuilder:是一个可变的字符串。字符串缓冲区类。 String和StringBuilder的区别： String的内容是固定的 StringBuilder的内容是可变的3.1.1 +&#x3D;拼接字符串耗费内存原因:每次拼接都会产生新的字符串对象,而利用StringBuilder来拼接字符串自始至终用的都是同一个StringBuilder容器3.2 StringBuilder类的常用方法 A:构造方法: StringBuilder() B:成员方法: public int capacity():返回当前容量 (理论值) public int length():返回长度(已经存储的字符个数)public StringBuilder append(任意类型):添加数据，并返回自身对象public StringBuilder reverse():反转功能3.2.1 案例代码十三:package com.itheima_01;&#x2F;* * StringBuilder:是一个可变的字符串。字符串缓冲区类。 * * String和StringBuilder的区别： * String的内容是固定的。 * StringBuilder的内容是可变的。 * * 构造方法： * StringBuilder() * * 成员方法： * public int capacity():返回当前容量 * public int length():返回长度（字符数） * * 容量：理论值 * 长度：实际值 *&#x2F;public class StringBuilderDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建对象 StringBuilder sb &#x3D; new StringBuilder(); System.out.println(&quot;sb:&quot;+sb); System.out.println(&quot;sb.capacity():&quot;+sb.capacity()); System.out.println(&quot;sb.length():&quot;+sb.length()); &#125;&#125;3.2.2 案例代码十四:package com.itheima_02;&#x2F;* * 添加功能 * public StringBuilder append(任意类型):添加数据，并返回自身对象 * 反转功能 * public StringBuilder reverse() *&#x2F;public class StringBuilderDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建对象 StringBuilder sb &#x3D; new StringBuilder(); &#x2F;&#x2F;public StringBuilder append(任意类型) &#x2F;&#x2F;StringBuilder sb2 &#x3D; sb.append(&quot;hello&quot;); &#x2F;* System.out.println(&quot;sb:&quot;+sb); System.out.println(&quot;sb2:&quot;+sb2); System.out.println(sb &#x3D;&#x3D; sb2); &#x2F;&#x2F;true *&#x2F; &#x2F;* sb.append(&quot;hello&quot;); sb.append(&quot;world&quot;); sb.append(true); sb.append(100); *&#x2F; &#x2F;&#x2F;链式编程 sb.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100); System.out.println(&quot;sb:&quot;+sb); &#x2F;&#x2F;public StringBuilder reverse() sb.reverse(); System.out.println(&quot;sb:&quot;+sb); &#125;&#125;3.3 StringBuilder案例3.3.1 案例一需求:StringBuilder和String通过方法完成相互转换3.3.1.1 案例代码十五:package com.itheima_03;&#x2F;* * StringBuilder和String的相互转换 * * StringBuilder -- String * public String toString():通过toString()就可以实现把StringBuilder转成String * * String -- StringBuilder * StringBuilder(String str):通过构造方法就可以实现把String转成StringBuilder *&#x2F;public class StringBuilderTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;StringBuilder -- String &#x2F;* StringBuilder sb &#x3D; new StringBuilder(); sb.append(&quot;hello&quot;).append(&quot;world&quot;); String s &#x3D; sb.toString(); System.out.println(s); *&#x2F; &#x2F;&#x2F;String -- StringBuilder String s &#x3D; &quot;helloworld&quot;; StringBuilder sb &#x3D; new StringBuilder(s); System.out.println(sb); &#125;&#125;3.3.2 案例二需求:利用StringBuilder把数组拼接成一个字符串 举例： int[] arr &#x3D; &#123;1,2,3&#125;; 结果： [1, 2, 3]3.3.2.1 案例代码十六:package com.itheima_03;&#x2F;* * 把数组拼接成一个字符串 * 举例： * int[] arr &#x3D; &#123;1,2,3&#125;; * 结果： * [1, 2, 3] *&#x2F;public class StringBuilderTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义一个数组 int[] arr &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F;写方法实现拼接 &#x2F;&#x2F;调用方法 String s &#x3D; arrayToString(arr); &#x2F;&#x2F;输出结果 System.out.println(&quot;s:&quot;+s); &#125; &#x2F;* * 两个明确： * 返回值类型：String * 参数列表：int[] arr *&#x2F; public static String arrayToString(int[] arr) &#123; StringBuilder sb &#x3D; new StringBuilder(); &#x2F;&#x2F;[1, 2, 3] sb.append(&quot;[&quot;); for(int x&#x3D;0; x&lt;arr.length; x++) &#123; if(x&#x3D;&#x3D;arr.length-1) &#123; sb.append(arr[x]); &#125;else &#123; sb.append(arr[x]).append(&quot;, &quot;); &#125; &#125; sb.append(&quot;]&quot;); String result &#x3D; sb.toString(); return result; &#125;&#125;3.3.3 案例三需求: 利用StringBuilder完成字符串反转3.3.3.1 案例代码十七:package com.itheima_03;import java.util.Scanner;&#x2F;* * 把字符串反转 * * 分析： * A:键盘录入一个字符串 * B:写方法实现反转 * String -- StringBuilder -- reverse() -- String * C:调用方法 * D:输出结果 *&#x2F;public class StringBuilderTest3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个字符串 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s &#x3D; sc.nextLine(); &#x2F;&#x2F;写方法实现反转 &#x2F;&#x2F;调用方法 String result &#x3D; myReverse(s); &#x2F;&#x2F;输出结果 System.out.println(&quot;result:&quot;+result); &#125; &#x2F;* * 两个明确： * 返回值类型：String * 参数列表：String *&#x2F; public static String myReverse(String s) &#123; &#x2F;&#x2F;String -- StringBuilder -- reverse() -- String StringBuilder sb &#x3D; new StringBuilder(s); sb.reverse(); String result &#x3D; sb.toString(); return result; &#125;&#125;3.3.4 案例四需求: 判断一个字符串是否是对称字符串 例如&quot;abc&quot;不是对称字符串，&quot;aba&quot;、&quot;abba&quot;、&quot;aaa&quot;、&quot;mnanm&quot;是对称字符串3.3.4.1 案例代码十八:package com.itheima_03;import java.util.Scanner;&#x2F;* * 判断一个字符串是否是对称字符串 * 例如&quot;abc&quot;不是对称字符串，&quot;aba&quot;、&quot;abba&quot;、&quot;aaa&quot;、&quot;mnanm&quot;是对称字符串 * * 分析： * A:键盘录入一个字符串 * B:写方法实现判断一个字符串是否是对称字符串 * 把字符串反转，和反转前的字符串进行比较，如果内容相同，就说明是对称字符串 * C:调用方法 * D:输出结果 *&#x2F;public class StringBuilderTest4 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个字符串 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s &#x3D; sc.nextLine(); &#x2F;&#x2F;写方法实现判断一个字符串是否是对称字符串 &#x2F;&#x2F;调用方法 boolean b &#x3D; isSymmetry(s); &#x2F;&#x2F;输出结果 System.out.println(&quot;b:&quot;+b); &#125; &#x2F;* * 两个明确： * 返回值类型：boolean * 参数列表：String s *&#x2F; public static boolean isSymmetry(String s) &#123; &#x2F;&#x2F;把字符串反转，和反转前的字符串进行比较，如果内容相同，就说明是对称字符串 StringBuilder sb &#x3D; new StringBuilder(s); sb.reverse(); String result &#x3D; sb.toString(); return result.equals(s); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"03-常用API","slug":"Note-Collections/JavaEE-学习笔记/03-常用API","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03-%E5%B8%B8%E7%94%A8API/"}]},{"title":"","date":"2019-09-19T00:06:58.638Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/10-类名作为形式参数和返回值/","text":"类名作为形式参数和返回值package com.itheima_10; public class Student { public void study() { System.out.println(“好好学习,天天向上”); }} package com.itheima_10; public class Teacher { public void test(Student s) { s.study(); }} package com.itheima_10; //需求： 调用Teacher的test方法 //类名作为形式参数：其实这里需要的是该类对象。public class Test { public static void main(String[] args) { Teacher t = new Teacher(); Student s = new Student(); t.test(s); }} package com.itheima_11; public class Teacher { public Student getStudent() { Student s = new Student(); return s; } } package com.itheima_11; //需求： 通过Teacher得到Student对象，然后调用Student类的方法//如果方法的返回值是类名：其实返回的是该类的对象public class Test { public static void main(String[] args) { Teacher t = new Teacher(); Student s = t.getStudent(); s.study(); }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.636Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/09-标准类写法和测试/","text":"标准类写法和测试package com.itheima_09;/* 学生类 /public class Student { //成员变量 private String name; private int age; //构造方法 public Student() {} public Student(String name,int age) { this.name = name; this.age = age; } //成员方法 public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; }} package com.itheima_09;/* 学生类的测试类 /public class StudentDemo { public static void main(String[] args) { //无参+setXxx() Student s = new Student(); s.setName(&quot;林青霞&quot;); s.setAge(28); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); //带参构造 Student s2 = new Student(&quot;林青霞&quot;,28); System.out.println(s2.getName()+&quot;---&quot;+s2.getAge()); }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.635Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/08-构造方法/","text":"构造方法package com.itheima_08;/* 构造方法： 给对象的数据进行初始化 格式： 方法名和类名相同 没有返回值类型，连void都不能写 没有具体的返回值 构造方法的注意事项： A:如果我们没有给出构造方法，系统将会提供一个默认的无参构造方法供我们使用。 B:如果我们给出了构造方法，系统将不在提供默认的无参构造方法供我们使用。 这个时候，如果我们想使用无参构造方法，就必须自己提供。 推荐：自己给无参构造方法 C:构造方法也是可以重载的 成员变量赋值： A:setXxx()方法 B:带参构造方法 /public class Student { private String name; private int age; /* public Student() { System.out.println(&quot;这是构造方法&quot;); } */ public Student() {} public Student(String name) { this.name = name; } public Student(int age) { this.age = age; } public Student(String name,int age) { this.name = name; this.age = age; } public void show() { System.out.println(name+&quot;---&quot;+age); }} package com.itheima_08; public class StudentDemo { public static void main(String[] args) { //如何调用构造方法呢? //通过new关键字调用 //格式：类名 对象名 = new 构造方法(…); Student s = new Student(); s.show(); //public Student(String name) Student s2 = new Student(&quot;林青霞&quot;); s2.show(); //public Student(int age) Student s3 = new Student(28); s3.show(); //public Student(String name,int age) Student s4 = new Student(&quot;林青霞&quot;,28); s4.show(); } }","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.635Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/07-this关键字/","text":"this关键字package com.itheima_07;/* 学生类 起名字我们要求做到见名知意。 而我们现在的代码中的n和a就没有做到见名知意，所以我要改进。 如果有局部变量名和成员变量名相同，在局部使用的时候，采用的是就近的原则。 我们有没有办法把局部变量的name赋值给成员变量的name呢? 有。 什么办法呢? 用this关键字就可以解决这个问题 this:代表所在类的对象引用 方法被哪个对象调用，this就代表那个对象 使用场景： 局部变量隐藏成员变量 /public class Student { private String name; private int age; public void setName(String name) { //“林青霞” //name = name; this.name = name; } public String getName() { return name; } public void setAge(int age) { //age = age; this.age = age; } public int getAge() { return age; }} package com.itheima_07;/* 学生类的测试类 /public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); s.setName(&quot;林青霞&quot;); s.setAge(28); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.634Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/06-成员变量私有的标准代码/","text":"成员变量私有标准代码package com.itheima_06;/* 学生类 /public class Student { private String name; private int age; public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; }} package com.itheima_06;/* 学生类的测试类 /public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); s.setName(&quot;林青霞&quot;); s.setAge(28); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.633Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/04-成员变量和局部变量/","text":"##成员变量和局部变量package com.itheima_04; 12345678910111213141516171819202122232425/* * 成员变量和局部变量的区别： * A:在类中的位置不同 * 成员变量：类中，方法外 * 局部变量：方法中或者方法声明上(形式参数) * B:在内存中的位置不同 * 成员变量：堆内存 * 局部变量：栈内存 * C:生命周期不同 * 成员变量：随着对象的创建而存在，随着对象的消失而消失 * 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 * D:初始化值的问题 * 成员变量：有默认值 * 局部变量：没有默认值。必须先定义，赋值，最后使用 */public class Variable &#123; int x; public void show() &#123; int y = 0; System.out.println(x); System.out.println(y); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.633Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/05-private关键字/","text":"private关键字package com.itheima_05;/* 学生类 通过对象直接访问成员变量，会存在数据安全问题 这个时候，我们就想能不能不让外界的对象直接访问成员变量呢? 能。 如何实现呢? private关键字 private: 是一个修饰符 可以修饰成员变量，也可以修饰成员方法 被private修饰的成员只能在本类中被访问 针对private修饰的成员变量，我们会相应的提供getXxx()和setXxx()用于获取和设置成员变量的值,方法用public修饰 /public class Student { String name; //int age; private int age; public void setAge(int a) { if(a&lt;0 || a&gt;200) { System.out.println(&quot;你给的年龄有误&quot;); }else { age = a; } } public int getAge() { return age; } public void show() { System.out.println(&quot;姓名是：&quot;+name+&quot;,年龄是：&quot;+age); }} package com.itheima_05;/* 学生类的测试类 /public class StudentDemo { public static void main(String[] args) { //创建学生对象 Student s = new Student(); s.show(); s.name = &quot;林青霞&quot;; //s.age = 28; //s.age = -28; //s.setAge(-28); s.setAge(28); s.show(); }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.632Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/03-对象的内存图/","text":"对象&amp;方法共用的内存图对象的内存图： 方法共用： 两个引用指向同一个对象：","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.632Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/02-编写类/","text":"编写类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima_02;/* * 类的定义： * 类是用来描述现实世界的事物的 * * 事物： * 属性 事物的描述信息 * 行为 事物能够做什么 * * 类是如何和事物进行对应的呢? * 类： * 成员变量 * 成员方法 * * 需求：写一个学生类 * * 学生事物： * 属性：姓名，年龄... * 行为：学习，吃饭... * * 学生类： * 成员变量：姓名,年龄 * 成员方法：学习,吃饭 * * 成员变量：和我们前面学习过的变量的定义是一样的。 * 位置不同：类中，方法外 * 初始化值：不需要给初始化值 * 成员方法：和我们前面学习过的方法的定义是一样的。 * 去掉static关键字 */public class Student &#123; //成员变量 //姓名 String name; //年龄 int age; //成员方法 //学习的方法 public void study() &#123; System.out.println(\"好好学习，天天向上\"); &#125; //吃饭的方法 public void eat() &#123; System.out.println(\"学习饿了要吃饭\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima_02;&#x2F;* * Student是一个学生事物描述类，main方法不适合放在它里面。 * * 使用一个类，其实就是使用该类的成员。(成员变量和成员方法) * 而我们要想使用一个类的成员，就必须首先拥有该类的对象。 * 我们如何拥有一个类的对象呢? * 创建对象就可以了? * 我们如何创建对象呢? * 格式：类名 对象名 &#x3D; new 类名(); * 对象如何访问成员呢? * 成员变量：对象名.变量名 * 成员方法：对象名.方法名(...) *&#x2F;public class StudentDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;格式：类名 对象名 &#x3D; new 类名(); Student s &#x3D; new Student(); &#x2F;&#x2F;System.out.println(&quot;s:&quot;+s); &#x2F;&#x2F;com.itheima_02.Student@193c0cf (new的对象在堆内存，堆内存打印地址值) &#x2F;&#x2F;直接输出成员变量值 System.out.println(&quot;姓名：&quot;+s.name); &#x2F;&#x2F;null System.out.println(&quot;年龄：&quot;+s.age); &#x2F;&#x2F;0 System.out.println(&quot;----------&quot;); &#x2F;&#x2F;给成员变量赋值 s.name &#x3D; &quot;林青霞&quot;; s.age &#x3D; 28; &#x2F;&#x2F;再次输出成员变量的值 System.out.println(&quot;姓名：&quot;+s.name); &#x2F;&#x2F;林青霞 System.out.println(&quot;年龄：&quot;+s.age); &#x2F;&#x2F;28 System.out.println(&quot;----------&quot;); &#x2F;&#x2F;调用成员方法 s.study(); s.eat(); &#125;&#125; 123456789101112131415161718192021222324package com.itheima_02;&#x2F;* * 手机类： * 成员变量：品牌，价格，颜色... * 成员方法：打电话，发短信... *&#x2F;public class Phone &#123; &#x2F;&#x2F;品牌 String brand; &#x2F;&#x2F;价格 int price; &#x2F;&#x2F;颜色 String color; &#x2F;&#x2F;打电话 public void call(String name) &#123; System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); &#125; &#x2F;&#x2F;发短信 public void sendMessage() &#123; System.out.println(&quot;群发短信&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.itheima_02;&#x2F;* * 手机类的测试类 *&#x2F;public class PhoneDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建对象 Phone p &#x3D; new Phone(); &#x2F;&#x2F;输出成员变量值 System.out.println(&quot;品牌：&quot;+p.brand);&#x2F;&#x2F;null System.out.println(&quot;价格：&quot;+p.price);&#x2F;&#x2F;0 System.out.println(&quot;颜色：&quot;+p.color);&#x2F;&#x2F;null System.out.println(&quot;------------&quot;); &#x2F;&#x2F;给成员变量赋值 p.brand &#x3D; &quot;锤子&quot;; p.price &#x3D; 2999; p.color &#x3D; &quot;棕色&quot;; &#x2F;&#x2F;再次输出成员变量值 System.out.println(&quot;品牌：&quot;+p.brand);&#x2F;&#x2F;锤子 System.out.println(&quot;价格：&quot;+p.price);&#x2F;&#x2F;2999 System.out.println(&quot;颜色：&quot;+p.color);&#x2F;&#x2F;棕色 System.out.println(&quot;------------&quot;); &#x2F;&#x2F;调用成员方法 p.call(&quot;林青霞&quot;); p.sendMessage(); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.631Z","path":"wiki/Note Collections/JavaEE 学习笔记/02-2.面向对象-封装/01-面向对象思想介绍/","text":"面向对象思想介绍 面向对象思想： 面向对象是基于面向过程的编程思想。 面向过程：强调的是每一个功能的步骤 面向对象：强调的是对象，然后由对象去调用功能 面向对象的思想特点： A:是一种更符合我们思考习惯的思想 B:可以将复杂的事情简单化 C:将我们从执行者变成了指挥者 举例： 买电脑： 面向过程：我要买电脑–我要明确买电脑的意义–上网查对应的参数信息–去中关村买电脑–讨价还价–买回电脑 面向对象：我要买电脑–班长去给我买电脑–买回电脑 洗衣服： 面向过程：把衣服脱下来–找一个盆–放点洗衣粉–加点水–浸泡10分钟–揉一揉–清洗衣服–拧干–晾起来 面向对象：把衣服脱下来–打开全自动洗衣机–扔衣服–按钮–晾起来 * 我们学习编程语言，其实就是为了把现实世界的事物模拟出来，实现信息化。 * * 我们是如何表示现实世界的事物的呢? * A:属性 就是事物的描述信息 * B:行为 就是事物能够做什么 * 举例：学生 * * Java语言最基本的单位是类，所以，我们在后面的学习过程中，是通过类来体现现实世界事物的。 * * 类：是一组相关的属性和行为的集合 * 对象：就是该事物的具体体现 * 举例： * 类 学生 * 对象 班长","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"02-2.面向对象-封装","slug":"Note-Collections/JavaEE-学习笔记/02-2-面向对象-封装","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"}]},{"title":"","date":"2019-09-19T00:06:58.630Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/14-1.14 基础语法练习/","text":"基础语法练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.itheima;import java.util.Scanner;&#x2F;* * 需求：键盘录入一个月份，输出该月份对应的季节。 * 一年有四季 * 3,4,5 春季 * 6,7,8 夏季 * 9,10,11 秋季 * 12,1,2 冬季 * * 分析： * A:键盘录入一个月份,用Scanner实现 * B:判断该月份是几月,根据月份输出对应的季节 * if * switch * * case穿透 *&#x2F;public class Test2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个月份,用Scanner实现 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入月份(1-12)：&quot;); int month &#x3D; sc.nextInt(); &#x2F;* switch(month) &#123; case 1: System.out.println(&quot;冬季&quot;); break; case 2: System.out.println(&quot;冬季&quot;); break; case 3: System.out.println(&quot;春季&quot;); break; case 4: System.out.println(&quot;春季&quot;); break; case 5: System.out.println(&quot;春季&quot;); break; case 6: System.out.println(&quot;夏季&quot;); break; case 7: System.out.println(&quot;夏季&quot;); break; case 8: System.out.println(&quot;夏季&quot;); break; case 9: System.out.println(&quot;秋季&quot;); break; case 10: System.out.println(&quot;秋季&quot;); break; case 11: System.out.println(&quot;秋季&quot;); break; case 12: System.out.println(&quot;冬季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); break; &#125; *&#x2F; &#x2F;* &#x2F;&#x2F;case穿透 switch(month) &#123; case 1: System.out.println(&quot;冬季&quot;); break; case 2: System.out.println(&quot;冬季&quot;); &#x2F;&#x2F;break; case 3: System.out.println(&quot;春季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); break; &#125; *&#x2F; switch(month) &#123; case 1: case 2: case 12: System.out.println(&quot;冬季&quot;); break; case 3: case 4: case 5: System.out.println(&quot;春季&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); break; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima;&#x2F;* * 需求： * 有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子， * 假如兔子都不死，问第二十个月的兔子对数为多少？ * * 规律： * 第一个月：1 * 第二个月：1 * 第三个月：2 * 第四个月：3 * 第五个月：5 * ... * * 规律：从第三个月开始，每个月的兔子对数是前两个月的兔子对数之和 * 第一个月和第二个月的兔子对数都是1 * * 分析： * A:由于数据比较多,所以我们就定义数组来实现了 * int[] arr &#x3D; new int[20]; * B:给数组的元素赋值 * arr[0] &#x3D; 1 * arr[1] &#x3D; 2 * C:找规律 * arr[2] &#x3D; arr[1] + arr[0]; * arr[3] &#x3D; arr[2] + arr[1]; * arr[4] &#x3D; arr[3] + arr[2]; * arr[5] &#x3D; arr[4] + arr[3]; * ... *&#x2F;public class Test4 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义数组 int[] arr &#x3D; new int[20]; &#x2F;&#x2F;给数组的元素赋值 arr[0] &#x3D; 1; arr[1] &#x3D; 1; &#x2F;&#x2F;找规律赋值 for(int x&#x3D;2; x&lt;arr.length; x++) &#123; arr[x] &#x3D; arr[x-1] + arr[x-2]; &#125; &#x2F;&#x2F;输出结果 System.out.println(&quot;第二十个月兔子的对数是：&quot;+arr[19]); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima;&#x2F;* * 需求： * (1)定义一个int类型的一维数组，内容为&#123;171,72,19,16,118,51,210,7,18&#125; * (2)求出该数组中满足要求的元素和。 * 要求：求和的元素的个位和十位不能包含7,并且只能为偶数。 * * 分析： * A:定义一个int类型的一维数组 * B:定义一个求和变量 * C:遍历数组,获取数组中的每一个元素 * D:判断该元素是否满足条件，如果满足条件就累加 * 假设该数据是x * 个位不能是7：x%10 !&#x3D; 7 * 十位不能是7：x&#x2F;10%10 !&#x3D; 7 * 必须是偶数：x%2 &#x3D;&#x3D; 0 * E:输出求和结果 *&#x2F;public class Test5 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义一个int类型的一维数组 int[] arr &#x3D; &#123;171,72,19,16,118,51,210,7,18&#125;; &#x2F;&#x2F;定义一个求和变量 int sum &#x3D; 0; &#x2F;&#x2F;遍历数组,获取数组中的每一个元素 for(int x&#x3D;0; x&lt;arr.length; x++) &#123; &#x2F;&#x2F;判断该元素是否满足条件，如果满足条件就累加 if((arr[x]%10 !&#x3D; 7) &amp;&amp; (arr[x]&#x2F;10%10 !&#x3D; 7) &amp;&amp; (arr[x]%2 &#x3D;&#x3D; 0)) &#123; sum +&#x3D; arr[x]; &#125; &#125; &#x2F;&#x2F;输出求和结果 System.out.println(&quot;sum:&quot;+sum); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.itheima;import java.util.Scanner;&#x2F;* *需求：数组元素查找(查找指定元素第一次在数组中出现的索引) *(1)给定数组int[] arr &#x3D; &#123;5,7,3,2,5&#125;; *(2)要查询的元素通过键盘录入的方式确定 *(3)定义一个查找数组元素第一次出现位置的方法(注,要查找的元素就是键盘录入的数据) * *分析： * A:定义数组int[] arr &#x3D; &#123;5,7,3,2,5&#125;; * B:键盘录入一个被查询的数据 * C:写方法实现查找指定元素在数组中第一次出现的索引 * 遍历数组，依次比较元素，如果相等，就把该处的索引返回即可 * D:调用方法,输出结果 *&#x2F;public class Test8 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义数组int[] arr &#x3D; &#123;5,7,3,2,5&#125;; int[] arr &#x3D; &#123;5,7,3,2,5&#125;; &#x2F;&#x2F;键盘录入一个被查询的数据 Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入被查询的数据：&quot;); int number &#x3D; sc.nextInt(); &#x2F;&#x2F;写方法实现查找指定元素在数组中第一次出现的索引 &#x2F;&#x2F;调用方法,输出结果 int index &#x3D; getIndex(arr, number); System.out.println(&quot;index:&quot;+index); &#125; &#x2F;* * 两个明确： * 返回值类型：int * 参数列表：int[] arr,int value *&#x2F; public static int getIndex(int[] arr,int value) &#123; &#x2F;&#x2F;遍历数组，依次比较元素，如果相等，就把该处的索引返回即可 for(int x&#x3D;0; x&lt;arr.length; x++) &#123; if(arr[x] &#x3D;&#x3D; value) &#123; return x; &#125; &#125; return -1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.itheima;import java.util.Scanner;&#x2F;* * 需求：键盘录入数据,要求数据是四位的整数,现需要对数据进行加密,加密规则如下: * 每位数字都加上5,然后除以10的余数代替该数字, * 再将第一位和第四位交换,第二位和第三位交换, * 请把加密后的数据输出到控制台 * * 分析： * A:键盘录入一个4位数 * 举例：4567 * B:定义一个长度为4的数组 * int[] arr &#x3D; new int[4]; * arr &#x3D; &#123;4,5,6,7&#125;; * C:对数组中的数据进行加密规则的操作 * 每位数字都加上5,然后除以10的余数代替该数字 * arr[x] +&#x3D; 5; * 结果：arr &#x3D; &#123;9,10,11,12&#125;; * arr[x] %&#x3D; 10; * 结果：arr &#x3D; &#123;9,0,1,2&#125;; * 再将第一位和第四位交换,第二位和第三位交换 * 结果：arr &#x3D; &#123;2,1,0,9&#125;; * D:请把加密后的数据输出到控制台 *&#x2F;public class Test9 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;键盘录入一个4位数 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入一个4位数：&quot;); int number &#x3D; sc.nextInt(); &#x2F;&#x2F;定义一个长度为4的数组 int[] arr &#x3D; new int[4]; arr[0] &#x3D; number&#x2F;10&#x2F;10&#x2F;10%10; arr[1] &#x3D; number&#x2F;10&#x2F;10%10; arr[2] &#x3D; number&#x2F;10%10; arr[3] &#x3D; number%10; &#x2F;&#x2F;对数组中的数据进行加密规则的操作 &#x2F;&#x2F;每位数字都加上5,然后除以10的余数代替该数字 for(int x&#x3D;0; x&lt;arr.length; x++) &#123; arr[x] +&#x3D; 5; arr[x] %&#x3D; 10; &#125; &#x2F;&#x2F;再将第一位和第四位交换,第二位和第三位交换 int temp &#x3D; arr[0]; arr[0] &#x3D; arr[3]; arr[3] &#x3D; temp; temp &#x3D; arr[1]; arr[1] &#x3D; arr[2]; arr[2] &#x3D; temp; &#x2F;&#x2F;请把加密后的数据输出到控制台 for(int x&#x3D;0; x&lt;arr.length; x++) &#123; System.out.print(arr[x]); &#125; System.out.println(); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.629Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/13-1.13 断点调试/","text":"1.12 断点调试","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.628Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/12-1.12 函数/","text":"## 1.12 函数 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima_01;import java.util.Scanner;&#x2F;* * 键盘录入两个数据，返回两个数中的较大值 *&#x2F;public class MethodTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入第一个数据：&quot;); int a &#x3D; sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int b &#x3D; sc.nextInt(); &#x2F;&#x2F;调用方法 int max &#x3D; getMax(a,b); &#x2F;&#x2F;输出结果 System.out.println(&quot;max:&quot;+max); &#125; &#x2F;* * 返回两个数中的较大值 * * 两个明确： * 返回值类型：int * 参数列表：int a,int b *&#x2F; public static int getMax(int a,int b) &#123; if(a &gt; b) &#123; return a; &#125;else &#123; return b; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima_01;import java.util.Scanner;&#x2F;* * 键盘录入两个数据，比较两个数是否相等 *&#x2F;public class MethodTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入第一个数据：&quot;); int x &#x3D; sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y &#x3D; sc.nextInt(); &#x2F;&#x2F;调用方法 boolean b &#x3D; compare(x,y); &#x2F;&#x2F;输出结果 System.out.println(&quot;b:&quot;+b); &#125; &#x2F;* * 比较两个数是否相等 * * 两个明确： * 返回值类型：boolean * 参数列表：int a,int b *&#x2F; public static boolean compare(int a,int b) &#123; if(a &#x3D;&#x3D; b)&#123; return true; &#125;else &#123; return false; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itheima_01;import java.util.Scanner;&#x2F;* * 键盘录入三个数据，返回三个数中的最大值 *&#x2F;public class MethodTest3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入第一个数据：&quot;); int a &#x3D; sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int b &#x3D; sc.nextInt(); System.out.println(&quot;请输入第三个数据：&quot;); int c &#x3D; sc.nextInt(); &#x2F;&#x2F;调用方法 int max &#x3D; getMax(a,b,c); &#x2F;&#x2F;输出结果 System.out.println(&quot;max:&quot;+max); &#125; &#x2F;* * 返回三个数中的最大值 * * 两个明确： * 返回值类型：int * 参数列表：int a,int b,int c *&#x2F; public static int getMax(int a,int b,int c) &#123; if(a &gt; b) &#123; if(a &gt; c) &#123; return a; &#125;else &#123; return c; &#125; &#125;else &#123; if(b &gt; c) &#123; return b; &#125;else &#123; return c; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829package com.itheima_02;&#x2F;* * 写一个方法，把所有的水仙花数打印在控制台 *&#x2F;public class MethodTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;调用方法 printFlower(); &#125; &#x2F;* * 写一个方法，把所有的水仙花数打印在控制台 * * 两个明确： * 返回值类型：void * 参数列表：无参数 *&#x2F; public static void printFlower() &#123; for(int x&#x3D;100; x&lt;1000; x++) &#123; int ge &#x3D; x%10; int shi &#x3D; x&#x2F;10%10; int bai &#x3D; x&#x2F;10&#x2F;10%10; if((ge*ge*ge+shi*shi*shi+bai*bai*bai) &#x3D;&#x3D; x) &#123; System.out.println(x); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima_03;&#x2F;* * 比较两个数据是否相等。参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型，并在main方法中进行测试 *&#x2F;public class MethodTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;System.out.println(compare(10, 20)); &#x2F;&#x2F;System.out.println(compare((byte)10, (byte)20)); &#x2F;&#x2F;System.out.println(compare((short)10, (short)20)); System.out.println(compare(10L, 20L)); &#125; &#x2F;&#x2F;byte public static boolean compare(byte a,byte b) &#123; System.out.println(&quot;byte&quot;); return a &#x3D;&#x3D; b; &#125; &#x2F;&#x2F;short public static boolean compare(short a,short b) &#123; System.out.println(&quot;short&quot;); return a &#x3D;&#x3D; b; &#125; &#x2F;&#x2F;int public static boolean compare(int a,int b) &#123; System.out.println(&quot;int&quot;); return a &#x3D;&#x3D; b; &#125; &#x2F;&#x2F;long public static boolean compare(long a,long b) &#123; System.out.println(&quot;long&quot;); return a &#x3D;&#x3D; b; &#125;&#125; 1234567891011121314151617181920212223242526package com.itheima_04;&#x2F;* * 方法的参数如果是基本数据类型：形式参数的改变不影响实际参数。 * * 形式参数：用于接收实际参数的变量 * 实际参数：实际参与运算的变量 *&#x2F;public class ArgsDemo &#123; public static void main(String[] args) &#123; int a &#x3D; 10; int b &#x3D; 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);&#x2F;&#x2F;a:10,b:20 change(a,b); System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);&#x2F;&#x2F;??? a:10,b:20 &#125; public static void change(int a,int b) &#123;&#x2F;&#x2F;a&#x3D;10,b&#x3D;20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);&#x2F;&#x2F;a:10,b:20 a &#x3D; b;&#x2F;&#x2F;a&#x3D;20 b &#x3D; a + b;&#x2F;&#x2F;b&#x3D;40 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);&#x2F;&#x2F;a:20,b:40 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima_05;&#x2F;* * 把获取数组最值改进为方法实现，并调用方法 * * 练习：最小值的方法练习。 *&#x2F;public class MethodTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义数组 int[] arr &#x3D; &#123;24,36,90,75,81&#125;; &#x2F;* &#x2F;&#x2F;定义参照物 int max &#x3D; arr[0]; &#x2F;&#x2F;遍历数组,获取元素,依次比较 for(int x&#x3D;1; x&lt;arr.length; x++) &#123; if(arr[x] &gt; max) &#123; max &#x3D; arr[x]; &#125; &#125; *&#x2F; &#x2F;&#x2F;写方法实现获取数组中的最大值 int max &#x3D; getMax(arr); &#x2F;&#x2F;输出结果 System.out.println(&quot;max:&quot;+max); &#125; &#x2F;* * 两个明确： * 返回值类型：int * 参数列表：int[] arr *&#x2F; public static int getMax(int[] arr) &#123; &#x2F;&#x2F;定义参照物 int max &#x3D; arr[0]; &#x2F;&#x2F;遍历数组,获取元素,依次比较 for(int x&#x3D;1; x&lt;arr.length; x++) &#123; if(arr[x] &gt; max) &#123; max &#x3D; arr[x]; &#125; &#125; return max; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.itheima_05;&#x2F;* * 写一个方法，用于对数组进行求和，并调用方法。 *&#x2F;public class MethodTest3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义数组 int[] arr &#x3D; &#123;1,2,3,4,5&#125;; &#x2F;* &#x2F;&#x2F;定义求和变量 int sum &#x3D; 0; &#x2F;&#x2F;获取数组中的每一个元素 for(int x&#x3D;0; x&lt;arr.length; x++) &#123; &#x2F;&#x2F;累加 sum +&#x3D; arr[x]; &#125; *&#x2F; &#x2F;&#x2F;写方法实现 int sum &#x3D; sum(arr); &#x2F;&#x2F;输出结果 System.out.println(&quot;sum:&quot;+sum); &#125; &#x2F;* * 两个明确： * 返回值类型：int * 参数列表：int[] arr *&#x2F; public static int sum(int[] arr) &#123; &#x2F;&#x2F;定义求和变量 int sum &#x3D; 0; &#x2F;&#x2F;获取数组中的每一个元素 for(int x&#x3D;0; x&lt;arr.length; x++) &#123; &#x2F;&#x2F;累加 sum +&#x3D; arr[x]; &#125; return sum; &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.627Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/10-1.10 数组/","text":"## 数组","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.627Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/11-1.11 Java的内存分配/","text":"1.11 Java 内存分配 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima_01;&#x2F;* * 定义两个数组，先定义一个数组，赋值，输出。然后定义第二个数组的时候把第一个数组的地址赋值给第二个数组。 * 然后给第二个数组赋值，再次输出两个数组的名及元素。 *&#x2F;public class ArrayTest3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义一个数组 int[] arr &#x3D; new int[3]; &#x2F;&#x2F;赋值 arr[0] &#x3D; 100; arr[1] &#x3D; 200; arr[2] &#x3D; 300; &#x2F;&#x2F;输出 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#x2F;&#x2F;然后定义第二个数组的时候把第一个数组的地址赋值给第二个数组。 int[] arr2 &#x3D; arr; &#x2F;&#x2F;给第二个数组赋值 arr2[0] &#x3D; 111; arr2[1] &#x3D; 222; arr2[2] &#x3D; 333; &#x2F;&#x2F;再次输出两个数组的名及元素 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125;&#125; 123456789101112131415161718192021222324package com.itheima_02;&#x2F;* * 静态初始化的格式： * 数据类型[] 数组名 &#x3D; new 数据类型[]&#123;元素1,元素2,元素3,...&#125;; * * 举例： * int[] arr &#x3D; new int[]&#123;1,2,3&#125;; * * 简化格式： * 数据类型[] 数组名 &#x3D; &#123;元素1,元素2,元素3,...&#125;; * int[] arr &#x3D; &#123;1,2,3&#125;; *&#x2F;public class ArrayDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义数组 int[] arr &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F;输出数组名和元素 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.626Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/09-1.9 随机数/","text":"随机数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima;import java.util.Random;import java.util.Scanner;&#x2F;* * 猜数字小游戏案例 * 系统产生一个1-100之间的随机数，请猜出这个数据是多少。 * * 分析： * A:系统产生一个1-100之间的随机数 * Random r &#x3D; new Random(); * int number &#x3D; r.nextInt(100) + 1; * B:键盘录入我们要猜的数据 * C:比较这两个数据,用if语句实现 * 大了：提示大了 * 小了：提示小了 * 猜中了：提示恭喜你,猜中了 * D:多次猜数据,而我们不知道猜多少次,怎么办呢? * while(true) &#123;循环体语句;&#125; *&#x2F;public class RandomTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;系统产生一个1-100之间的随机数 Random r &#x3D; new Random(); &#x2F;&#x2F;获取随机数 int number &#x3D; r.nextInt(100) + 1; &#x2F;&#x2F;多次猜数据 while(true) &#123; &#x2F;&#x2F;键盘录入我们要猜的数据 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入你要猜的数据(1-100)：&quot;); int guessNumber &#x3D; sc.nextInt(); &#x2F;&#x2F;比较这两个数据,用if语句实现 if(guessNumber &gt; number) &#123; System.out.println(&quot;你猜的数据&quot;+guessNumber+&quot;大了&quot;); &#125;else if(guessNumber &lt; number) &#123; System.out.println(&quot;你猜的数据&quot;+guessNumber+&quot;小了&quot;); &#125;else &#123; System.out.println(&quot;恭喜你,猜中了&quot;); break; &#125; &#125; &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.625Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/07-1.7 选择流程控制语句/","text":"选择流程控制语句if和switch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.itheima_02;import java.util.Scanner;&#x2F;* * 键盘录入学生考试成绩，请根据成绩判断该学生属于哪个级别 * 90-100 优秀 * 80-90 好 * 70-80 良 * 60-70 及格 * 60以下 不及格 * * 分析： * A:键盘录入学生考试成绩 * 三步骤 * B:通过简单的分析，我们决定采用if语句格式3来实现 * * 程序一定要考虑周全了。 * 安全数据 * 边界数据 * 错误数据 *&#x2F;public class IfTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入学生的考试成绩：&quot;); int score &#x3D; sc.nextInt(); &#x2F;&#x2F;if语句格式3 &#x2F;* if(score&gt;&#x3D;90 &amp;&amp; score&lt;&#x3D;100)&#123; System.out.println(&quot;你的成绩属于优秀&quot;); &#125;else if(score&gt;&#x3D;80 &amp;&amp; score&lt;90)&#123; System.out.println(&quot;你的成绩属于好&quot;); &#125;else if(score&gt;&#x3D;70 &amp;&amp; score&lt;80)&#123; System.out.println(&quot;你的成绩属于良&quot;); &#125;else if(score&gt;&#x3D;60 &amp;&amp; score&lt;70)&#123; System.out.println(&quot;你的成绩属于及格&quot;); &#125;else &#123; System.out.println(&quot;你的成绩属于不及格&quot;); &#125; *&#x2F; &#x2F;&#x2F;我们发现程序不够健壮,加入错误数据的判断 if(score&lt;0 || score&gt;100)&#123; System.out.println(&quot;你的成绩是错误的&quot;); &#125;else if(score&gt;&#x3D;90 &amp;&amp; score&lt;&#x3D;100)&#123; System.out.println(&quot;你的成绩属于优秀&quot;); &#125;else if(score&gt;&#x3D;80 &amp;&amp; score&lt;90)&#123; System.out.println(&quot;你的成绩属于好&quot;); &#125;else if(score&gt;&#x3D;70 &amp;&amp; score&lt;80)&#123; System.out.println(&quot;你的成绩属于良&quot;); &#125;else if(score&gt;&#x3D;60 &amp;&amp; score&lt;70)&#123; System.out.println(&quot;你的成绩属于及格&quot;); &#125;else &#123; System.out.println(&quot;你的成绩属于不及格&quot;); &#125; &#125;&#125;&#x2F;&#x2F;------------------------------------------------------------import java.util.Scanner;&#x2F;* * switch语句格式： * switch(表达式) &#123; * case 值1: * 语句体1; * break; * case 值2: * 语句体2; * break; * ... * default: * 语句体n+1; * break; * &#125; * 格式解释： * 表达式:byte,short,int,char * JDK5以后可以是枚举 * JDK7以后可以是字符串 * case:就是要和表达式进行比较的值 * break:表示中断,结束的意思。 * default:表示所有的情况都不匹配的时候，就执行语句体n+1。和if语句的else相似。 * 执行流程： * A:计算出表达式的值 * B:拿计算出来的值和case后面的值依次比较，一旦有对应的值，就执行该处的语句，在执行过程中，遇到 break，就结束。 * C:如果所有的case都不匹配，就会执行default控制的语句，然后结束。 * 需求： * 根据键盘录入的数值1，2，3，…7输出对应的星期一，星期二，星期三…星期日。 *&#x2F;public class SwitchDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建键盘录入对象 Scanner sc &#x3D; new Scanner(System.in); &#x2F;&#x2F;接收数据 System.out.println(&quot;请输入一个数字(1-7)：&quot;); int weekday &#x3D; sc.nextInt(); &#x2F;&#x2F;switch语句实现选择 switch(weekday) &#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期日&quot;); break; default: System.out.println(&quot;你输入的数字有误&quot;); break; &#125; &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.625Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/08-1.8 循环流程控制语句/","text":"循环流程控制语句for while do…while continue breakfor语句123456789101112131415161718192021222324252627282930313233package com.itheima_04;&#x2F;* * 需求：求出1-5之间数据之和 * * 分析： * A:定义求和变量，初始化值是0 * B:获取1-5之间的数据，用for循环实现 * C:把每一次获取到的数据，累加起来就可以了 * D:输出求和变量即可 *&#x2F;public class ForTest2 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义求和变量，初始化值是0 int sum &#x3D; 0; &#x2F;&#x2F;获取1-5之间的数据，用for循环实现 for(int x&#x3D;1; x&lt;&#x3D;5; x++) &#123; &#x2F;&#x2F;把每一次获取到的数据，累加起来就可以了 &#x2F;&#x2F;sum &#x3D; sum + x; &#x2F;* * 第一次：sum &#x3D; 0 + 1 &#x3D; 1 * 第二次：sum &#x3D; 1 + 2 &#x3D; 3 * 第三次：sum &#x3D; 3 + 3 &#x3D; 6 * 第四次：sum &#x3D; 6 + 4 &#x3D; 10 * 第五次：sum &#x3D; 10 + 5 &#x3D; 15 *&#x2F; sum +&#x3D; x; &#125; &#x2F;&#x2F;输出求和结果 System.out.println(&quot;sum:&quot;+sum); &#125;&#125; 12345678910111213141516171819202122232425262728package com.itheima_04;&#x2F;* * 需求：求出1-100之间偶数和 * * 分析： * A:定义求和变量，初始化值是0 * B:获取1-100之间的数据，用for循环实现 * C:把获取到的数据进行判断，看是否是偶数 * 如果是，就累加 * D:输出求和结果 *&#x2F;public class ForTest3 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义求和变量，初始化值是0 int sum &#x3D; 0; &#x2F;&#x2F;获取1-100之间的数据，用for循环实现 for(int x&#x3D;1; x&lt;&#x3D;100; x++) &#123; &#x2F;&#x2F;把获取到的数据进行判断，看是否是偶数 if(x%2 &#x3D;&#x3D;0) &#123; sum +&#x3D; x; &#125; &#125; &#x2F;&#x2F;输出求和结果 System.out.println(&quot;sum:&quot;+sum); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.itheima_04;&#x2F;* * 需求：在控制台输出所有的”水仙花数” * * 分析： * 什么是水仙花数呢? * 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 * 举例：153就是一个水仙花数。 * 153 &#x3D; 1*1*1 + 5*5*5 + 3*3*3 * * A:三位数其实就告诉了我们水仙花数的范围 * 100-999 * B:如何获取一个数据的每一个位上的数呢? * 举例：我有一个数据153，请问如何获取到个位，十位，百位 * 个位：153%10 &#x3D; 3; * 十位：153&#x2F;10%10 &#x3D; 5; * 百位：153&#x2F;10&#x2F;10%10 &#x3D; 1; * 千位：... * 万位：... * C:让每个位上的立方和相加，并和该数据进行比较，如果相等，就说明该数据是水仙花数，在控制台输出 *&#x2F;public class ForTest4 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;通过循环获取到每一个三位数 for(int x&#x3D;100; x&lt;1000; x++) &#123; &#x2F;&#x2F;获取个位，十位，百位 int ge &#x3D; x%10; int shi &#x3D; x&#x2F;10%10; int bai &#x3D; x&#x2F;10&#x2F;10%10; &#x2F;&#x2F;让每个位上的立方和相加，并和该数据进行比较，如果相等，就说明该数据是水仙花数，在控制台输出 if((ge*ge*ge+shi*shi*shi+bai*bai*bai) &#x3D;&#x3D; x) &#123; System.out.println(x); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132&#x2F;* * 需求：统计”水仙花数”共有多少个 * * 分析： * A:定义统计变量，初始化值是0 * B:获取三位数，用for循环实现 * C:获取三位数的个位，十位，百位 * D:判断这个三位数是否是水仙花数，如果是，统计变量++ * E:输出统计结果就可以了 *&#x2F;public class ForTest5 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;定义统计变量，初始化值是0 int count &#x3D; 0; &#x2F;&#x2F;获取三位数，用for循环实现 for(int x&#x3D;100; x&lt;1000; x++) &#123; &#x2F;&#x2F;获取三位数的个位，十位，百位 int ge &#x3D; x%10; int shi &#x3D; x&#x2F;10%10; int bai &#x3D; x&#x2F;10&#x2F;10%10; &#x2F;&#x2F;判断这个三位数是否是水仙花数，如果是，统计变量++ if((ge*ge*ge+shi*shi*shi+bai*bai*bai) &#x3D;&#x3D; x) &#123; count++; &#125; &#125; &#x2F;&#x2F;输出统计结果就可以了 System.out.println(&quot;水仙花数共有：&quot;+count+&quot;个&quot;); &#125;&#125; While语句12345678910111213141516171819202122232425262728293031package com.itheima_05;&#x2F;* * 求1-100之和。 * 练习：统计水仙花个数。 *&#x2F;public class WhileTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;回顾for循环实现 &#x2F;* &#x2F;&#x2F;定义求和变量 int sum &#x3D; 0; &#x2F;&#x2F;获取1-100之间的数据 for(int x&#x3D;1; x&lt;&#x3D;100; x++) &#123; &#x2F;&#x2F;累加 sum +&#x3D; x; &#125; System.out.println(&quot;1-100的和是：&quot;+sum); *&#x2F; &#x2F;&#x2F;while循环实现 &#x2F;&#x2F;定义求和变量 int sum &#x3D; 0; int x &#x3D; 1; while(x&lt;&#x3D;100) &#123; sum +&#x3D; x; x++; &#125; System.out.println(&quot;1-100的和是：&quot;+sum); &#125;&#125; do while123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima_06;&#x2F;* * 三种循环的区别： * A:do...while至少执行一次循环体 * B:for,while循环先判断条件是否成立，然后决定是否执行循环体 * * for和while的小区别： * for循环的初始化变量，在循环结束后，不可以被访问。而while循环的初始化变量，是可以被继续使用的。 * 如果初始化变量，后面还要继续访问，就使用while，否则，推荐使用for。 * * 循环的使用推荐： * for -- while -- do...while *&#x2F;public class DoWhileDemo2 &#123; public static void main(String[] args) &#123; &#x2F;* int x &#x3D; 3; while(x&lt;3) &#123; System.out.println(&quot;我爱林青霞&quot;); x++; &#125; System.out.println(&quot;--------------&quot;); int y &#x3D; 3; do &#123; System.out.println(&quot;我爱林青霞&quot;); y++; &#125;while(y&lt;3); *&#x2F; for(int x&#x3D;1; x&lt;&#x3D;10; x++)&#123; System.out.println(&quot;爱生活，爱Java&quot;); &#125; &#x2F;&#x2F;这里的x无法继续访问 &#x2F;&#x2F;System.out.println(x); System.out.println(&quot;-----------------&quot;); int y &#x3D; 1; while(y&lt;&#x3D;10) &#123; System.out.println(&quot;爱生活，爱Java&quot;); y++; &#125; System.out.println(y); &#125;&#125; continue break12345678910111213141516171819202122232425&#x2F;* * continue:继续的意思 * 使用场景： * 循环中 * 注意： * 离开使用场景是没有意义的 * 作用： * 结束一次循环，继续下一次的循环 * 区别： * break:退出循环 * continue:结束一次循环，继续下一次的循环 *&#x2F;public class ContinueDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;continue; for(int x&#x3D;1; x&lt;&#x3D;10; x++) &#123; if(x &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F;break; continue; &#125; System.out.println(&quot;HelloWorld&quot;); &#125; &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.624Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/06-1.6键盘录入/","text":"键盘录入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.itheima;import java.util.Scanner;/* * 为了提高程序的灵活性，我们就把数据改进为键盘录入。 * 如何实现键盘录入呢?目前我们只能使用JDK提供的类Scanner。 * 这个使用的步骤，目前大家记住就可以了。 * * 使用步骤： * A:导包 * import java.util.Scanner; * 类中的顺序：package &gt; import &gt; class * B:创建对象 * Scanner sc = new Scanner(System.in); * C:接收数据 * int i = sc.nextInt(); */public class ScannerDemo &#123; public static void main(String[] args) &#123; //创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //接收数据 System.out.println(\"请录入一个整数：\"); int i = sc.nextInt(); //输出数据 System.out.println(\"i:\"+i); &#125;&#125;/* * 键盘录入两个数据，并对这两个数据求和，输出其结果 * * 键盘录入： * A:导包 * B:创建对象 * C:接收数据 */public class ScannerTest &#123; public static void main(String[] args) &#123; // 创建对象 Scanner sc = new Scanner(System.in); // 接收数据 System.out.println(\"请输入第一个数据：\"); int a = sc.nextInt(); System.out.println(\"请输入第二个数据：\"); int b = sc.nextInt(); // 对数据进行求和 int sum = a + b; System.out.println(\"sum:\" + sum); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.623Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/05-1.5运算符&三元运算符/","text":"1.5 运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package com.itheima_04;/* * 逻辑运算符：用于连接关系表达式。 * &amp;,|,^,! * &amp;&amp;,|| * * 与：&amp; 有false则false * 或：| 有true则true * 异或：^ 相同则false,不同则true。(男女朋友) * 非：! true则false,false则true */public class OperatorDemo &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; int c = 30; System.out.println((a &gt; b) &amp; (a &gt; c));// false &amp; false System.out.println((a &lt; b) &amp; (a &gt; c)); // true &amp; false System.out.println((a &gt; b) &amp; (a &lt; c)); // false &amp; true System.out.println((a &lt; b) &amp; (a &lt; c)); // true &amp; true System.out.println(\"---------------\"); System.out.println((a &gt; b) | (a &gt; c));// false | false System.out.println((a &lt; b) | (a &gt; c)); // true | false System.out.println((a &gt; b) | (a &lt; c)); // false | true System.out.println((a &lt; b) | (a &lt; c)); // true | true System.out.println(\"---------------\"); System.out.println((a &gt; b) ^ (a &gt; c));// false ^ false System.out.println((a &lt; b) ^ (a &gt; c)); // true ^ false System.out.println((a &gt; b) ^ (a &lt; c)); // false ^ true System.out.println((a &lt; b) ^ (a &lt; c)); // true ^ true System.out.println(\"---------------\"); System.out.println((a &gt; b)); // false System.out.println(!(a &gt; b)); // !false System.out.println(!!(a &gt; b)); // !!false &#125;&#125;package com.itheima_04;/* * &amp;&amp;和&amp;的结果一样 * ||和|的结果一样 * * &amp;&amp;和&amp;的区别： * &amp;&amp;如果左边是false，右边不执行。 * &amp;无论左边是true还是false，右边都会执行。 */public class OperatorDemo2 &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; int c = 30; System.out.println((a &gt; b) &amp;&amp; (a &gt; c));// false &amp;&amp; false System.out.println((a &lt; b) &amp;&amp; (a &gt; c)); // true &amp;&amp; false System.out.println((a &gt; b) &amp;&amp; (a &lt; c)); // false &amp;&amp; true System.out.println((a &lt; b) &amp;&amp; (a &lt; c)); // true &amp;&amp; true System.out.println(\"---------------\"); System.out.println((a &gt; b) || (a &gt; c));// false || false System.out.println((a &lt; b) || (a &gt; c)); // true || false System.out.println((a &gt; b) || (a &lt; c)); // false || true System.out.println((a &lt; b) || (a &lt; c)); // true || true System.out.println(\"---------------\"); int x = 3; int y = 4; // System.out.println((x++ &gt; 4) &amp; (y++ &gt; 5)); // false &amp; false System.out.println((x++ &gt; 4) &amp;&amp; (y++ &gt; 5)); // false &amp;&amp; false System.out.println(\"x:\" + x); System.out.println(\"y:\" + y); &#125;&#125;/* * 三元运算符： * * 格式： * (关系表达式)?表达式1:表达式2; * 执行流程: * A:计算关系表达式的值，看是true还是false * B:如果是true,表达式1就是运算结果 * 如果是false,表达式2就是运算结果 */public class OperatorDemo &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; int c = (a &gt; b) ? a : b; System.out.println(\"c:\" + c); &#125;&#125;/* * 三元运算符的练习 * 比较两个整数是否相同 */public class OperatorTest &#123; public static void main(String[] args) &#123; // 定义两个int类型的变量 int a = 10; int b = 20; boolean flag = (a == b) ? true : false; // boolean flag = (a == b); System.out.println(flag); &#125;&#125;package com.itheima;import java.util.Scanner;/* * 键盘录入三个数据，获取这三个数据中的最大值 */public class ScannerTest3 &#123; public static void main(String[] args) &#123; // 创建对象 Scanner sc = new Scanner(System.in); // 接收数据 System.out.println(\"请输入第一个数据：\"); int a = sc.nextInt(); System.out.println(\"请输入第二个数据：\"); int b = sc.nextInt(); System.out.println(\"请输入第三个数据：\"); int c = sc.nextInt(); // 如何获取三个数据的最大值 int temp = (a &gt; b ? a : b); int max = (temp &gt; c ? temp : c); System.out.println(\"max:\" + max); &#125;&#125;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.622Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/04-1.4数据类型及转换/","text":"1.4 数据类型以及转换数据类型数据类型：Java是一种强类型语言，针对每一种数据都给出了明确的数据类型 数据类型分类： A:基本数据类型 B:引用数据类型(类,接口,数组) 基本数据类型：4类8种 A:整数 占用字节数 byte 1 short 2 int 4 long 8 B:浮点数 float 4 double 8 C:字符 char 2 D:布尔 boolean 1 注意： A:整数默认是int类型,浮点数默认是double B:定义long类型数据的时候，要加L或者l，建议加L 定义float类型数据的时候，要加F或者f，建议加F C:字符 Java中的字符采用的是unicode编码，每一个字符占用两个字节，就可以存储一个汉字 D:boolean类型适用于逻辑运算,一般用于流程控制 ![](assets/1/20180705-90d57ed1.png) 变量定义注意事项### 隐式转换 /* +:是一个运算符，做加法运算的。 我们在做运算的时候，一般要求参与运算的数据类型必须一致。 类型转换： 隐式转换 强制转换 隐式转换 byte,short,char -- int -- long -- float -- double*/ public class TypeCastDemo { public static void main(String[] args) { //直接输出了运算的结果 System.out.println(3 + 4); //定义两个int类型的变量 int a = 3; int b = 4; int c = a + b; System.out.println(c); //定义一个byte类型,定义一个int类型 byte bb = 2; int cc = 5; System.out.println(bb + cc); //我能不能不直接输出，用一个变量接受呢? //用变量接受，这个变量应该有类型 //可能损失精度 //byte dd = bb + cc; int dd = bb + cc; System.out.println(dd); }}","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.621Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/02-1.2环境变量配置/","text":"1.2环境变量配置1.根据电脑类型从官网下载最新JDK（需要同意协议）http://www.oracle.com/technetwork/java/javase/downloads/ 2.安装JDK和JRE 3.配置环境变量（win7系统）在计算机图表上右键——属性——高级系统设置——环境变量新建系统变量：点击系统变量下的“新建”按钮，输入变量名 JAVA_HOME ，变量值为JDK的安装路径 1JAVA_HOME 然后单机确定,修改Path变量：在系统变量中找到“Path”，点击“编辑”，在变量值的最前面添加 %JAVA_HOME%\\bin;然后确定 #### 4.在控制台输入 javac 命令确认环境是否配置正确出现以下内容表示配置正确","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.621Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/03-1.3Java入门/","text":"1.3JavaEE入门标识符组成及注意事项1234567891011标识符：就是给包,类,方法,变量起名字的符号。组成规则： A:unicode字符 数字字符,英文大小写,汉字(不建议使用汉字) B:下划线_ C:美元符$注意事项 A:不能以数字开头 B:不能是java中的关键字 常见命名规则：12345678910111213141516A:基本要求 见名知意B:常见的命名 a:包(其实就是文件夹,用于对类进行管理) 全部小写,多级包用.隔开 举例：com，com.itheima b:类 一个单词首字母大写 举例：Student,Car 多个单词每个单词的首字母大写 举例：HelloWorld c:方法和变量 一个单词首字母小写 举例：age,show() 多个单词从第二个单词开始每个单词的首字母大写 举例：maxAge,getAge()","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2019-09-19T00:06:58.620Z","path":"wiki/Note Collections/JavaEE 学习笔记/01-1.基础语法/01-1.1环境搭建与必要软件下载（IDE&JavaWeb）/","text":"1.1环境搭建与必要软件下载（IDE&amp;JavaWeb）Java环境下载与配置最新版本JDK下载：http://www.oracle.com/technetwork/java/javase/downloads/环境变量配置：http://blog.csdn.net/syjsxxjy/article/details/47838265 Eclipse下载http://www.eclipse.org/downloads/ Tomcat下载http://tomcat.apache.org/download-80.cgi或者使用eclipse创建Web工程时内建下载 JDBC/MySQL相关MySQL下载（windows）：http://dev.mysql.com/downloads/installer/ （可选是否安装WorkBench）JDBC驱动下载http://dev.mysql.com/downloads/connector/j/","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"JavaEE 学习笔记","slug":"Note-Collections/JavaEE-学习笔记","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"01-1.基础语法","slug":"Note-Collections/JavaEE-学习笔记/01-1-基础语法","permalink":"http://yoursite.com/categories/Note-Collections/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"Raspberry Pi Serverの説明","date":"2019-09-19T00:06:58.616Z","path":"wiki/Raspberry_Pi_PCR/Raspberry_Pi_Server/","text":"[TOC] RasPiのAP/NATとサーバーの構築(RasPiをアクセスポイント/NATとして使う)1．アクセスポイント（Wireless LAN access point）とはノートパソコン・スマートフォンなどの無線LANクライアント（無線端末）を、相互に接続したり、他のネットワーク（有線LAN等）に接続する無線機の一種。有線LANに接続すると，無線WiFiを作ること(シェア)ができます。 2．NAT（Network Address Translation）とはインターネットプロトコルによって構築されたコンピュータネットワークにおいて、パケットヘッダに含まれるIPアドレスを、別のIPアドレスに変換する技術である。ルーターから割り当てもらったIPアドレスを他のIPアドレスを変換する。メリットは，異なるIPアドレスが割り当てられても，RasPiが作ったWiFiに接続するクライアント設備に対して，RasPiのIPアドレスは変わらない。 3．RasPi Server** Wifiに接続 –&gt; RasPiサーバーをアクセス(固定IP) –&gt; ホームページでRasPiの情報が見える。 **RasPiを有線LANに接続するとホットスポットとして使う可能。スタンドアロンネットワーク(Local Network)でも動く。RasPi自体がLANケーブルが差し込まれていなくても，Wifi信号を送信する。ただしこの場合は，このWifiに接続する設備はインターネットには繋がってない。RasPiを中心で作られたローカルネットワークの中で，RasPiサーバーをアクセスして，ホームページを見ることができる。 4.RasPiのAPに接続12SSID：Pi-Server Password：12345678 5.RasPiのサーバーをアクセス次のIPをブラウザーで開く 1http:&#x2F;&#x2F;pi HelloWorldが出たら成功。 このページを快速アクセス本ページのURL：https://lovedva.github.io/wiki/Raspberry_Pi_PCR/Raspberry_Pi_Server/ 快速アクセス：1．https://lovedva.github.io にアクセス。 2．左側の「Raspberry_Pi_PCR←」を選択。 3．「Raspberry Pi Serverの説明」を選ぶ。","tags":[],"categories":[{"name":"Raspberry_Pi_PCR","slug":"Raspberry-Pi-PCR","permalink":"http://yoursite.com/categories/Raspberry-Pi-PCR/"}]},{"title":"","date":"2019-09-19T00:06:58.616Z","path":"wiki/Note Collections/窒息的操作/09-电路图/","text":"电路图","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"窒息的操作","slug":"Note-Collections/窒息的操作","permalink":"http://yoursite.com/categories/Note-Collections/%E7%AA%92%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"","date":"2019-09-19T00:06:58.615Z","path":"wiki/Note Collections/窒息的操作/06-PID算法及单片机实现/","text":"[TOC] PIDアルゴリズムによるフィードバック制御PID制御のプロセス Sv：設定された目標値Pv: 制御対象の現在値 PIDアルゴリズム1.MCU起動する以来センサーが採取した全部のサンプリングデータの行列** X1, X2, X3… Xk-1, Xk ** 2.現在のデータと目標値の偏差を計算** 現在の偏差：Ek=Sv-Xk ** Ek&lt;0の場合：目標に未着. Ek=0の場合：目標と一致. Ek&gt;0の場合：目標を超えている. 現在の偏差を操作量にすると，出力は** POUT=Kp・Ek+OUT0 (比例出力)**ここで，Kpは定数で比例ゲインと呼ばれる。Kpは現在の偏差を増幅/収縮させるための定数。OUT0はEk=0の時，出力を続けるの定数。 3．過去全部のサンプリング偏差値を行列にする** E1, E2, E3… Ek-1, Ek**これを全部足し算すると過去全部の偏差の和：Sk=E1+E2+E3+…+Ek-1,EkSk&lt;0の場合：今まで多くの時間は目標に未着 Sk=0の場合：今までは目標と一致。 Sk&gt;0の場合：今まで多くの時間は目標を超えている Skを出力にするとIOUT=Kp・Sk+OUT0 (積分出力) 4.現在と前の二つの偏差を引き算偏差値の差：Dk=Ek-Ek-1Dk&lt;0の場合：偏差の変化率は小さくなている Dk=0の場合：偏差は変わっていない Dk&gt;0の場合：偏差の変化率が大きくなる Dkを出力にするとDOUT=Kp・Dp+OUT0 (微分出力) 5.まとめとPID出力比例アルゴリズムP：現在の偏差だけを基づいて，操作量を出力。積分アルゴリズムI：過去全部の偏差を基づいて，操作量を出力。微分アルゴリズムD：誤差の変化率を基づいて，操作量を出力。これ全部まとめて出力にするとPIDout=Kp・(Ek+Sk+Dk)+OUT0 PID出力になる。 MCUを基づいてPIDのアルゴリズム1．Skの公式T:サンプリングの周期Ti：積分時間（過去から現在まで時間） 2.Dkの公式Td：微分時間 3．まとめてPIDの公式 パラメーターの調整PID制御の各パラメータの値（Kp、Ti、Td）は設計値なので、制御対象とは独立に自由に与えることができ、要求を満たす最適な値を決定する必要がある。しかし、一般的な制御対象に対して、最適なゲイン値を与える代数的な方法は存在せず、実際の調整は、数値シミュレーションを行ったり、実際の対象物に調整器を繋いで試行錯誤的に最適値を得ている。 参考文献https://ja.wikipedia.org/wiki/PID%E5%88%B6%E5%BE%A1","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"窒息的操作","slug":"Note-Collections/窒息的操作","permalink":"http://yoursite.com/categories/Note-Collections/%E7%AA%92%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"","date":"2019-09-19T00:06:58.615Z","path":"wiki/Note Collections/窒息的操作/07-记录/","text":"记录1.马达控制器 Controller针脚接法： P1-P3按钮针脚P1：GPIO16（正转）P2：GPIO15（停止）P3：GPIO7（反转）P4：马达+P5：马达-P6：驱动控制信号in1 GPIO19P7：驱动控制信号in2 GPIO13P8（Msourse）: 马达电源VCC：接5V电源（树莓派可）GND：接GND P9:电热丝电源12VP10：GNDP11：GPIO树莓派P12：接负载+P13：接负载- 2.电热器3V：最高30度？5V：最高54.75度左右。12V：50度：36度~50度 5分钟稳定70度：5分钟稳定90度：5分稳定 3.配件型号フォトカプラ TLP241PchパワーMOSFET 2sj681 60v5A 4.图片素材 用到的py库adafruit mcp3008adafruit max31655i2c adt7410传感器 smbuspygame 还没搞完py xls pip install openpyxl","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"窒息的操作","slug":"Note-Collections/窒息的操作","permalink":"http://yoursite.com/categories/Note-Collections/%E7%AA%92%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"","date":"2019-09-19T00:06:58.614Z","path":"wiki/Note Collections/窒息的操作/05-马达控制方案（按钮+蓝牙）/","text":"[TOC] モーター制御RaspberryPiの起動と電子回路の給電1．USB3.0ケーブルを電源端子に差込み電気を供給する。携帯の充電器が利用できる。2．LED1(赤)が点灯するまで待つ。3．LED1が点灯すると，制御プログラムが実行中となる。4．モータの給電は別の外部電源から供給する。 RasPiのGPIO番号詳しい説明はこちらで：https://pinout.xyz/ モータ制御回路と配線1．TA7291P(モータドライバ)の端子説明：Datasheetはこちらで：http://akizukidenshi.com/download/ta7291p.pdf ​ 1 2 3 4 5 GND モータ±端子 × +5V電源 GPIO13(制御信号入力) 6 7 8 9 10 GPIO19(制御信号入力) +5V電源 12V500mAモータ電源 × モータ±端子 2．回路図と配線:** 1)素子と部品:**マイコン:RasPi 3モータ:DCモータ電源:12Vと５Vモータドライバ:TA7291Pジャンパーワイヤー抵抗:220Ω ≤ 抵抗値 ≤ 2000Ω であればOKボタンスイッチ：1個LED：1個 2)TA7291Pピン番号： 3)回路図: 配線： 制御の操作(Bluetoothとボタンスイッチ)Bluetoothデバイスで制御(配線不要)1．Bluetoothデバイスを検出可能にする。2．RasPiを起動する。LED1が点灯するまで，Bluetoothデバイスの電源が切れないようにする。3．Bluetooth機器との接続が失敗した場合は，LED1は3回点滅する。 #プログラムの途中で接続が切れた場合は，10秒後で再接続を行ってください。4．SW1ボタンを1回押し，Bluetooth機器に再接続ができる。5．Joyconの場合は，いずれかのボタンを押したら電源オンになる。6．ボタンBで正回転，ボタンAとYは停止，ボタンXで逆回転（速く押さないでください）。 #回転方向を変えるには，必ず停止をしてから，再回転をはじめる。 #正回転→停止→逆回転 #停止しないと，モータに損傷が発生する。7．Joyconの側面のボタンを押すと，電源を切る。 ボタンスイッチで制御1．スイッチ配線： 2．正転→停止→逆転 で操作してください。3．速く押さないでください。4．RasPiのUSBケーブルを抜いて全体をオフにする。 参考文献「これ1冊でできる！ラズベリー・パイ超入門」 福田 和宏Pythonライブラリ： https://www.pygame.org/docs/ref/joystick.html#pygame.joystick.JoystickTA7291PのDatasheet：http://akizukidenshi.com/download/ta7291p.pdfRasPiのGPIO番号：https://pinout.xyz/fritzing:http://fritzing.org/home/任天堂： https://support.nintendo.co.jp/app/answers/detail/a_id/33820/~/%E3%80%90switch%E3%80%91joy-con%E3%82%84nintendo-switch-pro-%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%E3%81%8C%E6%9C%AC%E4%BD%93%E3%81%AB%E8%AA%8D%E8%AD%98%E3%81%95%E3%82%8C%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"窒息的操作","slug":"Note-Collections/窒息的操作","permalink":"http://yoursite.com/categories/Note-Collections/%E7%AA%92%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"","date":"2019-09-19T00:06:58.613Z","path":"wiki/Note Collections/窒息的操作/04-数字电位器控制说明/","text":"デジタル可変抵抗プログラム説明1．ソースコードは次のページで見るhttps://github.com/syjsxxjy/shabi/blob/master/python/digital_re.py更新したらこのページで確認できる。 2．コードをダウンロードRasPiターミナルでコマンドを使う場合 123git clone https:&#x2F;&#x2F;github.com&#x2F;syjsxxjy&#x2F;shabi.gitcd shabi&#x2F;pythonsudo python digital_re.py HTTPでダウンロードhttps://github.com/syjsxxjy/shabi/blob/master/python/digital_re.py 3．使い方キーボードでテストポイントを移動させる。移動方向は &gt;&gt;&gt; と &lt;&lt;&lt; です。","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"窒息的操作","slug":"Note-Collections/窒息的操作","permalink":"http://yoursite.com/categories/Note-Collections/%E7%AA%92%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"Stm32 单片机","date":"2019-09-19T00:06:58.609Z","path":"wiki/Note Collections/硬件/06-Stm32单片机/","text":"Stm32单片机STM32F103用户数据手册中文版下载https://pan.baidu.com/s/1sr4O7pZqzNnOFw8AKQpblASTM32F10XXX参考手册：https://pan.baidu.com/s/1hAlXzvLCtWAJgwOZSvNZGQSTM32F103X8-B数据手册（中文）https://pan.baidu.com/s/1ZjC5Yu_8N-k1wRSiCS8mhA","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"硬件","slug":"Note-Collections/硬件","permalink":"http://yoursite.com/categories/Note-Collections/%E7%A1%AC%E4%BB%B6/"}]},{"title":"PFR series电源","date":"2019-09-19T00:06:58.608Z","path":"wiki/Note Collections/硬件/03-PFRseries电源/","text":"PFR series电源驱动，说明书下载官网地址：http://www.texio.co.jp/product/detail/152驱动： http://www.texio.co.jp/uploads/Sample_PFR.zip说明书：http://www.texio.co.jp/uploads/PFR_UM_20180315.pdf编程说明：http://www.texio.co.jp/uploads/PFR_PM_20180315.pdf","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"硬件","slug":"Note-Collections/硬件","permalink":"http://yoursite.com/categories/Note-Collections/%E7%A1%AC%E4%BB%B6/"}]},{"title":"树莓派","date":"2019-09-19T00:06:58.608Z","path":"wiki/Note Collections/硬件/04-树莓派/","text":"[TOC] 树莓派基础配置信息系统镜像：https://www.raspberrypi.org/downloads/VNCviewer：https://www.realvnc.com/en/connect/download/viewer/镜像写入工具（win32diskimager）（win7）：https://sourceforge.net/projects/win32diskimager/Wifi远控设定：https://qiita.com/Spike_Han/items/d1ad4e53373935701b1a网络配置：https://www.raspberrypi.org/documentation/configuration/wireless/wireless-cli.mdAP设置：https://www.raspberrypi.org/documentation/configuration/wireless/access-point.md#internet-sharing raspi-config设置里，预设网络interface设置为否，不然报错 eth0接口不存在。Vim教程：http://www.runoob.com/linux/linux-vim.html串口数据线连接方式：绿色-gpio15 黄色-gpio14 进程相关按crl+Z把进程放入后台，然后杀掉ps -l 列出与本次登录有关的进程信息；ps -aux 查询内存中进程信息；ps -aux | grep * 查询*进程的详细信息；top 查看内存中进程的动态信息；kill -9 pid 杀死进程。 Flask服务器Flask 服务器基础配置：https://projects.raspberrypi.org/en/projects/python-web-server-with-flask/8Flask 文档： https://dormousehole.readthedocs.io/en/latest/tutorial/layout.html http://flask.pocoo.org/Alternatively you can use python -m flask: 1234export FLASK_APP&#x3D;piserverexport FLASK_ENV&#x3D;developmentpython -m flask run --host&#x3D;0.0.0.0* Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F; 开机自动运行sudo crontab -e@reboot cd /home/pi/shabi/piserver; sudo python app.py &amp; ####jquery Ajaxjs-&gt;post/get-&gt;py脚本控制gpio-&gt;脚本返回response结果-&gt;ajax/js读取结果-&gt;显示到页面 git使用https的url设置远程git，不要用ssh。 1234567891011git init git status git add --all git commit -am &#39;add json rules and python program&#39; git remote add origin：httpsgit push -u origin mastergit push origin mastergit log snitch-sniffer.pygit checkout 5fd772a292c019a7cf3012b1156685280d4a7d2d snitch-sniffer.pygit commit -am &#39;restore find function&#39; vim全选:ggVG把文件类型设为html，然后全选代码执行”=”号emmt:在输入模式下，按下ctrl+y然后按下”，” utf8设定在最前面加上 12#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*- 树莓派输出电流电压设置一、打开config.txt文件在底部加上max_usb_current=1此时输出电流最大为1.2A GPIO工作方式pin接地=0，接电源=1。什么都不接=电压跳跃。https://raspberrypi.stackexchange.com/questions/14680/raspberry-pi-gpio-input-pins-give-random-values VNC启动：vncserver :1用系统用户名和密码登录（pi ras）远程复制粘贴：https://raspberrypi.stackexchange.com/questions/4474/tightvnc-copy-paste-between-local-os-and-raspberry-pi 按键防抖http://www.eeworld.com.cn/mcu/2015/1109/article_23492.html Joy-Stick 键值A:0 B:2 X:1 Y:3HOME:12 SL:4 SR:5 PLUS:9R:14 ZR:15 Pi Zero官网：https://www.raspberrypi.org/products/raspberry-pi-zero-w/针脚详细：https://pinout.xyz/pinout/serial_pi_zero禁止串口登录（用串口连接其它外设时）：https://www.abelectronics.co.uk/kb/article/20/raspberry-pi-serial-port-usage ####vim配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+&#x3D;~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin(&#39;~&#x2F;some&#x2F;path&#x2F;here&#39;)&quot; let Vundle manage Vundle, requiredPlugin &#39;VundleVim&#x2F;Vundle.vim&#39;&quot; The following are examples of different formats supported.&quot; Keep Plugin commands between vundle#begin&#x2F;end.&quot; plugin on GitHub repoPlugin &#39;tpope&#x2F;vim-fugitive&#39;&quot; plugin from http:&#x2F;&#x2F;vim-scripts.org&#x2F;vim&#x2F;scripts.html&quot; Plugin &#39;L9&#39;&quot; Git plugin not hosted on GitHubPlugin &#39;git:&#x2F;&#x2F;git.wincent.com&#x2F;command-t.git&#39;&quot; git repos on your local machine (i.e. when working on your own plugin)Plugin &#39;file:&#x2F;&#x2F;&#x2F;home&#x2F;gmarik&#x2F;path&#x2F;to&#x2F;plugin&#39;&quot; The sparkup vim script is in a subdirectory of this repo called vim.&quot; Pass the path to set the runtimepath properly.Plugin &#39;rstacruz&#x2F;sparkup&#39;, &#123;&#39;rtp&#39;: &#39;vim&#x2F;&#39;&#125;&quot; Install L9 and avoid a Naming conflict if you&#39;ve already installed a&quot; different version somewhere else.&quot; Plugin &#39;ascenator&#x2F;L9&#39;, &#123;&#39;name&#39;: &#39;newL9&#39;&#125;&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append &#96;!&#96; to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append &#96;!&#96; to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append &#96;!&#96; to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this lineau BufNewFile,BufRead *.py \\ set tabstop&#x3D;4 \\ set softtabstop&#x3D;4 \\ set shiftwidth&#x3D;4 \\ set textwidth&#x3D;79 \\ set expandtab \\ set autoindent \\ set fileformat&#x3D;unixau BufNewFile,BufRead *.js, *.html, *.css \\ set tabstop&#x3D;2 \\ set softtabstop&#x3D;2 \\ set shiftwidth&#x3D;2&quot;寻找全局配置文件 let g:ycm_global_ycm_extra_conf &#x3D; &#39;~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;cpp&#x2F;ycm&#x2F;.ycm_extra_conf.py&#39; &quot; 禁用syntastic来对python检查 let g:syntastic_ignore_files&#x3D;[&quot;.*\\.py$&quot;] &quot; 使用ctags生成的tags文件 let g:ycm_collect_identifiers_from_tag_files &#x3D; 1 &quot; 开启语义补全 &quot; 修改对C语言的补全快捷键，默认是CTRL+space，修改为ALT+;未测出效果 &quot;let g:ycm_key_invoke_completion &#x3D; &#39;&lt;M-;&gt;&#39; &quot; 设置转到定义处的快捷键为ALT+G，未测出效果 &quot;nmap &lt;M-g&gt; :YcmCompleter GoToDefinitionElseDeclaration &#x3D;expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; &quot;关键字补全 &quot;let g:ycm_seed_identifiers_with_syntax &#x3D; 1 &quot; 在接受补全后不分裂出一个窗口显示接受的项 set completeopt-&#x3D;preview &quot; 让补全行为与一般的IDE一致 set completeopt&#x3D;longest,menu &quot; 不显示开启vim时检查ycm_extra_conf文件的信息 let g:ycm_confirm_extra_conf&#x3D;0 &quot; 每次重新生成匹配项，禁止缓存匹配项 let g:ycm_cache_omnifunc&#x3D;0 &quot; 在注释中也可以补全 let g:ycm_complete_in_comments&#x3D;1 &quot; 输入第一个字符就开始补全 let g:ycm_min_num_of_chars_for_completion&#x3D;1 &quot; 错误标识符 let g:ycm_error_symbol&#x3D;&#39;&gt;&gt;&#39; &quot; 警告标识符 let g:ycm_warning_symbol&#x3D;&#39;&gt;*&#39; &quot; 不查询ultisnips提供的代码模板补全，如果需要，设置成1即可 &quot; let g:ycm_use_ultisnips_completer&#x3D;0Plugin &#39;vim-scripts&#x2F;indentpython.vim&#39;Plugin &#39;scrooloose&#x2F;syntastic&#39;Plugin &#39;nvie&#x2F;vim-flake8&#39;Plugin &#39;Lokaltog&#x2F;vim-powerline&#39;Plugin &#39;scrooloose&#x2F;nerdtree&#39;Plugin &#39;Yggdroot&#x2F;indentLine&#39;Plugin &#39;jiangmiao&#x2F;auto-pairs&#39;Plugin &#39;tell-k&#x2F;vim-autopep8&#39;Plugin &#39;scrooloose&#x2F;nerdcommenter&#39;Plugin &#39;Valloric&#x2F;YouCompleteMe&#39;Plugin &#39;mattn&#x2F;emmet-vim&#39;&quot;Plugin &#39;https:&#x2F;&#x2F;github.com&#x2F;scrooloose&#x2F;nerdtree&#39;nnoremap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr(&quot;$&quot;) &#x3D;&#x3D; 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&quot;缩进指示线&quot;let g:indentLine_char&#x3D;&#39;┆&#39;let g:indentLine_enabled &#x3D; 1&quot;&quot;autopep8设置&quot;let g:autopep8_disable_show_diff&#x3D;1map &lt;F4&gt; &lt;leader&gt;ci &lt;CR&gt;let python_highlight_all&#x3D;1syntax onset encoding&#x3D;utf-8set nu","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"硬件","slug":"Note-Collections/硬件","permalink":"http://yoursite.com/categories/Note-Collections/%E7%A1%AC%E4%BB%B6/"}]},{"title":"ds18b20 温度传感器","date":"2019-09-19T00:06:58.607Z","path":"wiki/Note Collections/硬件/02-ds18b20温度传感器/","text":"ds18b20 温度传感器类型：针脚：S：DQ（数据传送） 中间：VDD（电源） -：GND 参考文献：https://yamashitakoji.com/2016/05/raspberry-pi-ds18b20.html","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"硬件","slug":"Note-Collections/硬件","permalink":"http://yoursite.com/categories/Note-Collections/%E7%A1%AC%E4%BB%B6/"}]},{"title":"","date":"2019-09-19T00:06:58.606Z","path":"wiki/Note Collections/硬件/00-树莓派/06-树莓派无显示器串口控制操作初始设定/","text":"[TOC] 树莓派无显示器串口控制操作初始设定0.目录1.2准备工作1.3USB-TTL连接树莓派串口1.4修改系统配置，启用串口登录树莓派1.5启动树莓，用Putty连接并登录。2.参考来源 准备工作1.首先，初始设定必须通过实体介质（网线or串口线）才能够完成，不通过任何介质是无法操作树莓派的。 网线连接方案请看：https://qiita.com/Spike_Han/items/d1ad4e53373935701b1a2.初始设定完成后，可以通过连接无线网的方式用SSH远程登录树莓派实现远程操作。3.也可以继续使用串口通信登录树莓，缺点是无法让树莓使用其它串口设备以及蓝牙。4.所需外设： 读卡器，SD卡，USB-TTL转换模块（USB转串口模块）5.关于USB-TTL转换模块：目前这种产品有很多种类型，有转换线样子的，也有类似于板子的模块，选择自己中意的即可。不再单独做说明，因为每种都不一样，需要注意的是，请一定要阅读对应的说明书和安装驱动不要忘记安装对应的驱动。不要忘记安装对应的驱动。（重要的事情说三遍）有些模块需要自己根据不同需求去焊接不同的焊点，以实现更加丰富的功能，请仔细阅读说明书。如果担心不会用，就直接去淘宝买一个树莓专用的USB-TTL转换模块or线。 USB-TTL连接树莓派串口1.请仔细阅读说明书连接对应串口将对应针脚连接到树莓的TXD和RXD上（GPIO14和15），如图所示：来源：https://pinout.xyz/pinout/uart然後根据说明书，将Ground和电源接好。 修改系统配置，启用串口登录树莓派1.打开SD卡根目录的”config.txt”文件，将以下内容添加在最后并且保存。（文件所在位置请参考网线方案那篇文章） 1dtoverlay&#x3D;pi3-miniuart-bt 这样就停止了蓝牙，解除了对串口的占用。2.然后再修改根目录的”cmdline.txt”，将里面的内容全部替换成以下内容，以防万一，请先备份好这个文件的原内容。 1dwc_otg.lpm_enable&#x3D;0 console&#x3D;tty1 console&#x3D;serial0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 rootfstype&#x3D;ext4 elevator&#x3D;deadline fsck.repair&#x3D;yes rootwait 配置修改完成。 启动树莓，用Putty连接并登录。1.准备好上面的步骤之后，将SD卡插入树莓，接上电源启动。2.右键我的的电脑（以win7为例，其它大同小异）-&gt;管理-&gt;设备管理器-&gt;端口（COM和LPT）P.S：COM在Win系统里就是指的串口的端口。如果没有这个，说明你的转换模块没有在运作，请检查对应驱动是否正确安装。3.记下这里的端口号（这里是COM4）。4.用Putty或者其它远控软件新建一个连接，速度设置为115200，端口选择刚才的端口，如下图所示：5.点击连接，等待终端出现文字，直到树莓派发出登录请求，到此成功。 参考来源：http://akkagi.info/20161004_web/","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"硬件","slug":"Note-Collections/硬件","permalink":"http://yoursite.com/categories/Note-Collections/%E7%A1%AC%E4%BB%B6/"},{"name":"00-树莓派","slug":"Note-Collections/硬件/00-树莓派","permalink":"http://yoursite.com/categories/Note-Collections/%E7%A1%AC%E4%BB%B6/00-%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"批处理","date":"2019-09-19T00:06:58.596Z","path":"wiki/Note Collections/批处理/","text":"批处理复制文件夹下所有文件和子文件夹并覆盖12345::指定文件夹自己修改&quot; d:\\123&quot;set out&#x3D;D:\\download\\Nutstore\\WikiProject\\syjsxxjy.coding.me\\myblog\\library::复制当前路径所有文件和文件夹，至OUT路径文件夹xcopy &#x2F;e&#x2F;c&#x2F;h&#x2F;z &quot;%~pd0*.*&quot; &quot;%out%&quot;pause 本机开启AP需要管理员权限，bat批处理： 123netsh wlan set hostednetwork mode&#x3D;allow ssid&#x3D;share key&#x3D;12345678netsh wlan start hostednetworkpause 停止AP 1netsh wlan stop hostednetwork 切换语言显示netstat -anob” 命令的作用是查询端口的状态以及监听该端口的程序。2“chcp 437” 命令的作用是更改代码页。437 是美国英语的代码页936 是中文的代码页，936就是cmd默认的代码页932 日文代码页chcp 是 “change code page”的缩写3“color /?”命令的作用是查询color命令的使用方法。","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"}]},{"title":"Linux","date":"2019-09-19T00:06:58.595Z","path":"wiki/Note Collections/Codes/08-Linux/","text":"Linux笔记常用命令从当前screen切换到主窗口按下 Crl+A+D screen -R starbound chkconfig –list 可以用 service xxxx stop 来停止。 xxx表示相关服务sysv-rc-conf cp -v A/a1 B/chmod -R 755 /home/userchown www:www -R /home/wwwroot/test.nocryplay.com/chmod -R 777 /home/wwwroot/www.nocryplay.com/ 删除 rm -rf 删除当前目录所有文件 rm -rf $PWD 进程查看：查看： ps -ef | grep 程序名关闭：kill -15 进程号（查看时会显示出对应的进程号，15不行换9-强制关闭） 开机启动：sudo nano /etc/rc.localpython /home/pi/myscript.py &amp; Debian配置无线网络重启无线网络 ：重启网络 sudo /etc/init.d/networking restart Buffalo-G-2A30 d3rcsxrf4ka7eSPWN_N34_370b4b 1d92a7b5d2866 root登录SSH以及密码设置设置root密码：sudo passwd root今天安装了Ubuntu Server 14.04 发现配置了root密码后竟然不能ssh登陆，但是su root正常！ why？ 原来新版本里面sshd_config里面有了限制 12345678#vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password #找到这里，把它注释PermitRootLogin yes #改为yes 然后重启sshStrictModes yes#service ssh restart 程序相关lnmpLNMP 1.2及更高版本防跨目录功能使用.user.ini，该文件在网站根目录下，可以修改open_basedir的值来设置限制目录的访问。.user.ini文件无法直接修改，而且是隐藏文件可能在winscp下可能无法看到，建议使用vim编辑器或nano编辑器进行修改。如要修或删除需要先执行：chattr -i /网站目录/.user.ini修改完成后再执行：chattr +i /网站目录/.user.ini.user.ini不需要重启一般5分钟左右生效。如果要更改网站目录必须要按上述方法修改防跨目录的设置，否则肯定报错！！ 伪静态管理LNMPA或LAMP可以直接使用网站根目录下放.htaccess 来设置伪静态规则(具体规则可以去程序官网网站找google百度)，但是在LNMP下，需要使用Nginx伪静态规则。伪静态可以随时添加或删除，如果添加完虚拟主机后忘记或没有添加伪静态，可以通过修改配置文件来添加伪静态。虚拟主机配置文件在：/usr/local/nginx/conf/vhost/域名.conf 伪静态规则文件需要放在/usr/local/nginx/conf/ 下面。编辑虚拟主机配置文件，可以使用vi、nano或winscp，后2个工具对新手来说简单些。 例如前面我们添加的虚拟主机，打开后前半部分配置会显示如下：在root /home/wwwroot/www.vpser.net; 这一行下面添加：include wordpress.conf;上面的wordpress.conf为伪静态文件，如需要其他伪静态文件自己创建个并上传到/usr/local/nginx/conf/ 下面并include 伪静态.conf; 加完保存，执行：/etc/init.d/nginx restart 重启生效，如果报错可能是添加有误或伪静态规则有误。 pygame模块https://elinux.org/RPi_Debian_Python3#PyGame_Module尽量使用Raspbian完整版，精简版有各种莫名其妙的问题♂ ### VIM键盘图","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"Codes","slug":"Note-Collections/Codes","permalink":"http://yoursite.com/categories/Note-Collections/Codes/"}]},{"title":"Python","date":"2019-09-19T00:06:58.594Z","path":"wiki/Note Collections/Codes/07-Python/","text":"Python字符串操作website = ‘%s%s%s’ % (‘python’, ‘tab’, ‘.com’)print (“a= %s”) %(variable) GPIO module Libraryhttps://sourceforge.net/p/raspberry-gpio-python/wiki/Inputs/GPIO.add_event_detect(17, GPIO.FALLING, callback=lambda x: buttonPressed(50), bouncetime=2000) Defining the EncodingsecureCRT 显示中文方法：http://blog.csdn.net/guoyjoe/article/details/44964897https://www.python.org/dev/peps/pep-0263/Python will default to ASCII as standard encoding if no other encoding hints are given. To define a source code encoding, a magic comment must be placed into the source files either as first or second line in the file, such as: 1# coding&#x3D;&lt;encoding name&gt; or (using formats recognized by popular editors): 12#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: &lt;encoding name&gt; -*- or: 12#!&#x2F;usr&#x2F;bin&#x2F;python# vim: set fileencoding&#x3D;&lt;encoding name&gt; :","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"Codes","slug":"Note-Collections/Codes","permalink":"http://yoursite.com/categories/Note-Collections/Codes/"}]},{"title":"Git","date":"2019-09-19T00:06:58.592Z","path":"wiki/Note Collections/Codes/04-Git/","text":"GitGithub Desktop 设置代理https://stackoverflow.com/questions/16153450/github-windows-client-behind-proxy Add these entried to your ‘.gitconfig’ file in your user directory (go to %USERPROFILE%): [http] proxy = http://: [https] proxy = https://:And if you don’t want to store your password in plaintext, I would use a local proxy forwarder like CNTLM which allows you to direct all traffic through it and can store the passwords hashed. 注释在前面加上 # 清除所有历史记录（Pack文件过大）https://www.cnblogs.com/gaowengang/p/10955871.html","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"Codes","slug":"Note-Collections/Codes","permalink":"http://yoursite.com/categories/Note-Collections/Codes/"}]},{"title":"Markdown","date":"2019-09-19T00:06:58.592Z","path":"wiki/Note Collections/Codes/05-markdown/","text":"Markdown中文语法说明http://www.appinn.com/markdown/ 相对路径使用1**プロキシーが要る場合は先に[プロクシーを設定](index.html?file&#x3D;2-RaspberryPi&#x2F;01-Raspberry%20Piの初期設定&#x2F;03-＃プロキシーの設定)してください** 控制图片大小1&lt;IMG src&#x3D;&quot;assets&#x2F;2&#x2F;20171108-917f60a8.png&quot; width&#x3D;&quot;60%&quot; &gt;","tags":[],"categories":[{"name":"Note Collections","slug":"Note-Collections","permalink":"http://yoursite.com/categories/Note-Collections/"},{"name":"Codes","slug":"Note-Collections/Codes","permalink":"http://yoursite.com/categories/Note-Collections/Codes/"}]}]}